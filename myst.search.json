{"version":"1","records":[{"hierarchy":{"lvl1":"MetPy Cookbook"},"type":"lvl1","url":"/","position":0},{"hierarchy":{"lvl1":"MetPy Cookbook"},"content":"\n\n\n\n\n\n\n\n\n\n\n\nThis Cookbook is the oversized recipe book for all your MetPy needs.\nWe provide a gallery of real workflows centered around meteorological data,\nand the building blocks you need to recreate those workflows or cook up brand new ones yourself.\nCreate the maps and analyses you’ve seen from class and professional institutions alike!","type":"content","url":"/","position":1},{"hierarchy":{"lvl1":"MetPy Cookbook","lvl2":"Authors"},"type":"lvl2","url":"/#authors","position":2},{"hierarchy":{"lvl1":"MetPy Cookbook","lvl2":"Authors"},"content":"MetPy Maintainers and the MetPy Community.","type":"content","url":"/#authors","position":3},{"hierarchy":{"lvl1":"MetPy Cookbook","lvl3":"Contributors","lvl2":"Authors"},"type":"lvl3","url":"/#contributors","position":4},{"hierarchy":{"lvl1":"MetPy Cookbook","lvl3":"Contributors","lvl2":"Authors"},"content":"","type":"content","url":"/#contributors","position":5},{"hierarchy":{"lvl1":"MetPy Cookbook","lvl2":"Structure"},"type":"lvl2","url":"/#structure","position":6},{"hierarchy":{"lvl1":"MetPy Cookbook","lvl2":"Structure"},"content":"","type":"content","url":"/#structure","position":7},{"hierarchy":{"lvl1":"MetPy Cookbook","lvl3":"The MetPy Example Gallery","lvl2":"Structure"},"type":"lvl3","url":"/#the-metpy-example-gallery","position":8},{"hierarchy":{"lvl1":"MetPy Cookbook","lvl3":"The MetPy Example Gallery","lvl2":"Structure"},"content":"","type":"content","url":"/#the-metpy-example-gallery","position":9},{"hierarchy":{"lvl1":"MetPy Cookbook","lvl2":"Running the Notebooks"},"type":"lvl2","url":"/#running-the-notebooks","position":10},{"hierarchy":{"lvl1":"MetPy Cookbook","lvl2":"Running the Notebooks"},"content":"You can either run the notebook using \n\nBinder or on your local machine.","type":"content","url":"/#running-the-notebooks","position":11},{"hierarchy":{"lvl1":"MetPy Cookbook","lvl3":"Running on Binder","lvl2":"Running the Notebooks"},"type":"lvl3","url":"/#running-on-binder","position":12},{"hierarchy":{"lvl1":"MetPy Cookbook","lvl3":"Running on Binder","lvl2":"Running the Notebooks"},"content":"The simplest way to interact with a Jupyter Notebook is through\n\n\nBinder, which enables the execution of a\n\n\nJupyter Book in the cloud. The details of how this works are not\nimportant for now. All you need to know is how to launch a Pythia\nCookbooks chapter via Binder. Simply navigate your mouse to\nthe top right corner of the book chapter you are viewing and click\non the rocket ship icon, (see figure below), and be sure to select\n“launch Binder”. After a moment you should be presented with a\nnotebook that you can interact with. I.e. you’ll be able to execute\nand even change the example programs. You’ll see that the code cells\nhave no output at first, until you execute them by pressing\nShift+Enter. Complete details on how to interact with\na live Jupyter notebook are described in \n\nGetting Started with\nJupyter.","type":"content","url":"/#running-on-binder","position":13},{"hierarchy":{"lvl1":"MetPy Cookbook","lvl3":"Running on Your Own Machine","lvl2":"Running the Notebooks"},"type":"lvl3","url":"/#running-on-your-own-machine","position":14},{"hierarchy":{"lvl1":"MetPy Cookbook","lvl3":"Running on Your Own Machine","lvl2":"Running the Notebooks"},"content":"If you are interested in running this material locally on your computer, you will need to follow this workflow:\n\nClone the https://github.com/ProjectPythia/metpy-cookbook repository: git clone https://github.com/ProjectPythia/metpy-cookbook.git\n\nMove into the metpy-cookbook directorycd metpy-cookbook\n\nCreate and activate your conda environment from the environment.yml fileconda env create -f environment.yml\nconda activate metpy-cookbook\n\nMove into the notebooks directory and start up Jupyter Labcd notebooks/\njupyter lab","type":"content","url":"/#running-on-your-own-machine","position":15},{"hierarchy":{"lvl1":"Most-Unstable Convective Available Potential Energy (MUCAPE)"},"type":"lvl1","url":"/notebooks/convective/mucape","position":0},{"hierarchy":{"lvl1":"Most-Unstable Convective Available Potential Energy (MUCAPE)"},"content":"Calculate MUCAPE on a grid of netCDF data using MetPy.\n\n## importing all the packages we might need later for our calculation\nimport metpy.calc as mpcalc\nimport xarray as xr\nimport numpy as np\nfrom metpy.calc import cape_cin, surface_based_cape_cin, dewpoint_from_specific_humidity, parcel_profile,relative_humidity_from_specific_humidity,most_unstable_cape_cin, precipitable_water \nfrom metpy.units import units\nimport matplotlib.pyplot as plt\nimport cartopy.crs as ccrs\nimport cartopy.feature as cfeature\n\n## opening NetCDF file using xarray \n\nds = xr.open_dataset(\"NETCDF_FILE.nc\", decode_times=True)\n\nds\n\n#### making a function to slice the xarray dataset according to our need.\ndef slicer (data,lat1, lat2, lon1, lon2, time1,time2) :\n    sliced_data = data.sel(lat =slice(lat1, lat2), lon = slice(lon1, lon2),time = slice(time1, time2))\n    return sliced_data\n\n#slicing the data for CONUS only\n\nnew_data = slicer(ds,23.5,50.5,-125.5,-66.5, ds.time[0], ds.time[0])\n\nnew_data\n\n##extracting temperature, pressure  and specific humidity from the dataset\np =new_data.lev*units('hPa')\nT = new_data.T\nsh =  new_data.QV*units('dimensionless')\n\n\n\n\nCAPE = np.zeros((1, 28, 60),dtype=float)\n\n\n###calculating CAPE in multidimension\n\nfor h in range (len(new_data.time)):\n    for i in range (len(new_data.lat)):\n        for j in range(len(new_data.lon)):\n\n\n            TC = (T[h,:,i,j]-(273.15))*units('degC')\n            Td = dewpoint_from_specific_humidity(np.array(p)*units('hPa'),TC, sh[h,:,i,j])\n#      \n            try: \n                MUCAPE = most_unstable_cape_cin(np.array(p)*units('hPa'),np.array(TC)*units('degC'), np.array(Td)*units('degC'))\n            except:\n                pass\n            CAPE[h,i,j] = MUCAPE[0].magnitude\n          \n        \n            \n   \n\n\ndataproj = ccrs. PlateCarree ()\n# # Plot projection\n# # The look you want for the view.\nplotproj = ccrs. PlateCarree ()\nfig=plt.figure(1, figsize=(15.,12.))\n\nax=plt.subplot(111,projection=plotproj)\n\nax.add_feature(cfeature.COASTLINE, linewidth=0.5)\nax.add_feature(cfeature.STATES, linewidth=0.5)\nplt.title(\"MUCAPE Calculated Using Metpy (J/Kg)\",size = 30)\nplt.contourf (new_data.lon, new_data. lat, CAPE[0,:,:],levels =np.arange(0,2400,100),cmap = \"PuBuGn\", transform=dataproj,extend = \"max\")\nplt.colorbar (orientation = \"horizontal\", pad=0.01).ax.tick_params(labelsize=20)\nplt. show ()","type":"content","url":"/notebooks/convective/mucape","position":1},{"hierarchy":{"lvl1":"Total Column Precipitable Water (TCPW)"},"type":"lvl1","url":"/notebooks/convective/tcpw","position":0},{"hierarchy":{"lvl1":"Total Column Precipitable Water (TCPW)"},"content":"Calculate TCPW on a grid of netCDF data using MetPy.\n\nimport metpy.calc as mpcalc\nimport xarray as xr\nimport numpy as np\nfrom metpy.calc import cape_cin, surface_based_cape_cin, dewpoint_from_specific_humidity, parcel_profile,relative_humidity_from_specific_humidity,most_unstable_cape_cin, precipitable_water \nfrom metpy.units import units\nimport matplotlib.pyplot as plt\nimport cartopy.crs as ccrs\nimport cartopy.feature as cfeature\n\n## opening NetCDF file using xarray \n\nds = xr.open_dataset(\"NETCDF_FILE.nc\", decode_times=True)\n\nds\n\n#### making a function to slice the xarray dataset according to our need.\ndef slicer (data,lat1, lat2, lon1, lon2, time1,time2) :\n    sliced_data = data.sel(lat =slice(lat1, lat2), lon = slice(lon1, lon2),time = slice(time1, time2))\n    return sliced_data\n\n#slicing the data for CONUS only\n\nnew_data = slicer(ds,23.5,50.5,-125.5,-66.5, ds.time[0], ds.time[0])\n\nnew_data\n\n##extracting temperature, pressure  and specific humidity from the dataset\np =new_data.lev*units('hPa')\nT = new_data.T\nsh =  new_data.QV*units('dimensionless')\n\n\nTCPW = np.zeros((1, 28, 60),dtype=float)\n\n###calculating TCPW in multidimension\n\nfor h in range (len(new_data.time)):\n    for i in range (len(new_data.lat)):\n        for j in range(len(new_data.lon)):\n\n\n            TC = (T[h,:,i,j]-(273.15))*units('degC')\n            Td = dewpoint_from_specific_humidity(np.array(p)*units('hPa'),TC, sh[h,:,i,j])\n\n            TPW_S = precipitable_water(np.array(p)*units('hPa'), np.array(Td)*units('degC'))\n            TCPW[h,i,j] = TPW_S.magnitude\n                \n         \n\n\n\n\nTCPW\n\ndataproj = ccrs. PlateCarree ()\n# # Plot projection\n# # The look you want for the view.\nplotproj = ccrs. PlateCarree ()\nfig=plt.figure(1, figsize=(15.,12.))\n\nax=plt.subplot(111,projection=plotproj)\n\nax.add_feature(cfeature.COASTLINE, linewidth=0.5)\nax.add_feature(cfeature.STATES, linewidth=0.5)\nplt.title(\"Total Column Precipitable Water Calculated Using Metpy (mm)\",size = 30)\nplt.contourf (new_data.lon, new_data.lat, TCPW[0,:,:],levels =np.arange(0,70,5),cmap = \"PuBuGn\", transform=dataproj,extend = \"max\")\nplt.colorbar (orientation = \"horizontal\", pad=0.01).ax.tick_params(labelsize=20)\nplt. show ()","type":"content","url":"/notebooks/convective/tcpw","position":1},{"hierarchy":{"lvl1":"Convective Calculations"},"type":"lvl1","url":"/notebooks/convective","position":0},{"hierarchy":{"lvl1":"Convective Calculations"},"content":"This section covers how to perform a variety of calculations around analyzing convection and severe weather.","type":"content","url":"/notebooks/convective","position":1},{"hierarchy":{"lvl1":"Miller Composite Chart"},"type":"lvl1","url":"/notebooks/convective/miller-composite","position":0},{"hierarchy":{"lvl1":"Miller Composite Chart"},"content":"Create a Miller Composite chart based on Miller 1972 in Python with MetPy and\nMatplotlib.\n\nfrom datetime import datetime, timedelta\n\nimport cartopy.crs as ccrs\nimport cartopy.feature as cfeature\nimport matplotlib.lines as lines\nimport matplotlib.patches as mpatches\nimport matplotlib.pyplot as plt\nimport metpy.calc as mpcalc\nimport numpy as np\nimport numpy.ma as ma\n\nfrom metpy.units import units\nfrom netCDF4 import num2date\nfrom scipy.ndimage import gaussian_filter\nfrom siphon.catalog import TDSCatalog\nfrom xarray.backends import NetCDF4DataStore\nimport xarray as xr\n\nGet the data\n\nThis example will use data from the North American Mesoscale Model Analysis for 18 UTC 27 April 2011.\n\n# Specify our date/time of product desired\ndt = datetime(2011, 4, 27, 18)\n\n# Construct the URL for our THREDDS Data Server Catalog,\n# and access our desired dataset within via NCSS\nbase_url = 'https://www.ncei.noaa.gov/thredds/model-namanl-old/'\ncat = TDSCatalog(f'{base_url}{dt:%Y%m}/{dt:%Y%m%d}/catalog.xml')\nncss = cat.datasets[f'namanl_218_{dt:%Y%m%d}_{dt:%H}00_000.grb'].subset()\n\n# Create our NCSS query with desired specifications\nquery = ncss.query()\nquery.all_times()\nquery.add_lonlat()\nquery.lonlat_box(-135, -60, 15, 65)\nquery.variables('Geopotential_height_isobaric',\n                'u-component_of_wind_isobaric',\n                'v-component_of_wind_isobaric',\n                'Temperature_isobaric',\n                'Relative_humidity_isobaric',\n                'Best_4_layer_lifted_index_layer_between_two_pressure_'\n                'difference_from_ground_layer',\n                'Absolute_vorticity_isobaric',\n                'Pressure_reduced_to_MSL_msl',\n                'Dew_point_temperature_height_above_ground')\n\n# Obtain the data we've queried for\ndata_18z = ncss.get_data(query)\n\n# Make into an xarray Dataset object\nds_18z = xr.open_dataset(NetCDF4DataStore(data_18z)).metpy.parse_cf()\n\n# Assign variable names to collected data\nlat = ds_18z.lat\nlon = ds_18z.lon\n\n# Create more useable times for output\ntimes = ds_18z.Geopotential_height_isobaric.metpy.time.squeeze()\nvtimes = times.values.astype('datetime64[ms]').astype('O')\n\ntemps = ds_18z.Temperature_isobaric.squeeze()\nuwnd = ds_18z['u-component_of_wind_isobaric'].squeeze()\nvwnd = ds_18z['v-component_of_wind_isobaric'].squeeze()\nhgt = ds_18z.Geopotential_height_isobaric.squeeze()\nrelh = ds_18z.Relative_humidity_isobaric.squeeze()\nlifted_index = ds_18z['Best_4_layer_lifted_index_layer_between_two_'\n                      'pressure_difference_from_ground_layer'].squeeze()\nTd_sfc = ds_18z.Dew_point_temperature_height_above_ground.squeeze()\navor = ds_18z.Absolute_vorticity_isobaric.squeeze()\npmsl = ds_18z.Pressure_reduced_to_MSL_msl.squeeze()\n\nRepeat the above process to query for the analysis from 12 hours earlier (06 UTC) to calculate pressure falls and height change.\n\ntd = timedelta(hours=12)\n\nncss_06z = cat.datasets[f'namanl_218_{dt:%Y%m%d}_{dt-td:%H}00_000.grb'].subset()\n\nquery = ncss_06z.query()\nquery.all_times()\nquery.add_lonlat()\nquery.lonlat_box(-135, -60, 15, 65)\nquery.variables('Geopotential_height_isobaric',\n                'Pressure_reduced_to_MSL_msl')\n\n# Actually getting the data\ndata_06z = ncss_06z.get_data(query)\n\n# Make into an xarray Dataset object\nds_06z = xr.open_dataset(NetCDF4DataStore(data_06z)).metpy.parse_cf()\n\nhgt_06z = ds_06z.Geopotential_height_isobaric.squeeze()\npmsl_06z = ds_06z.Pressure_reduced_to_MSL_msl.squeeze()\n\nSubset the Data\n\nWith the data pulled in, we will now subset to the specific levels desired\n\n# 300 hPa\nu_300 = uwnd.metpy.sel(vertical=300*units.hPa).metpy.convert_units('kt').squeeze()\nv_300 = vwnd.metpy.sel(vertical=300*units.hPa).metpy.convert_units('kt').squeeze()\n\n# 500 hPa\navor_500 = avor.metpy.sel(vertical=500*units.hPa)\nu_500 = uwnd.metpy.sel(vertical=500*units.hPa).metpy.convert_units('kt').squeeze()\nv_500 = vwnd.metpy.sel(vertical=500*units.hPa).metpy.convert_units('kt').squeeze()\nhgt_500 = hgt.metpy.sel(vertical=500*units.hPa).squeeze()\nhgt_500_06z = hgt_06z.metpy.sel(vertical=500*units.hPa).squeeze()\n\n# 700 hPa\ntmp_700 = temps.metpy.sel(vertical=700*units.hPa).metpy.convert_units('degC').squeeze()\nrh_700 = relh.metpy.sel(vertical=700*units.hPa).squeeze()\n\n# 850 hPa\nu_850 = uwnd.metpy.sel(vertical=850*units.hPa).metpy.convert_units('kt').squeeze()\nv_850 = vwnd.metpy.sel(vertical=850*units.hPa).metpy.convert_units('kt').squeeze()\n\nPrepare Variables for Plotting\n\nWith the data queried and subset, we will make any needed calculations in preparation for\nplotting.\n\nThe following fields should be plotted:\n\n500-hPa cyclonic vorticity advection\n\nSurface-based Lifted Index\n\nThe axis of the 300-hPa, 500-hPa, and 850-hPa jets\n\nSurface dewpoint\n\n700-hPa dewpoint depression\n\n12-hr surface pressure falls and 500-hPa height changes\n\n# 500 hPa CVA\nvort_adv_500 = mpcalc.advection(avor_500, u_500, v_500,) * 1e9\nvort_adv_500_smooth = gaussian_filter(vort_adv_500, 4)\n\nFor the jet axes, we will calculate the windspeed at each level, and plot the highest values\n\nwspd_300 = gaussian_filter(mpcalc.wind_speed(u_300, v_300), 5)\nwspd_500 = gaussian_filter(mpcalc.wind_speed(u_500, v_500), 5)\nwspd_850 = gaussian_filter(mpcalc.wind_speed(u_850, v_850), 5)\n\n700-hPa dewpoint depression will be calculated from Temperature_isobaric and RH\n\nTd_dep_700 = tmp_700 - mpcalc.dewpoint_from_relative_humidity(tmp_700, rh_700)\n\n12-hr surface pressure falls and 500-hPa height changes\n\npmsl_change = pmsl.metpy.quantify() - pmsl_06z.metpy.quantify()\nhgt_500_change = hgt_500.metpy.quantify() - hgt_500_06z.metpy.quantify()\n\nTo plot the jet axes, we will mask the wind fields below the upper 1/3 of windspeed.\n\n# 500 hPa\nu_500_masked = u_500.where(wspd_500 > 0.66 * wspd_500.max(), np.nan)\nv_500_masked = v_500.where(wspd_500 > 0.66 * wspd_500.max(), np.nan)\n\n# 300 hPa\nu_300_masked = u_300.where(wspd_300 > 0.66 * wspd_300.max(), np.nan)\nv_300_masked = v_300.where(wspd_300 > 0.66 * wspd_300.max(), np.nan)\n\n# 850 hPa\nu_850_masked = u_850.where(wspd_850 > 0.66 * wspd_850.max(), np.nan)\nv_850_masked = v_850.where(wspd_850 > 0.66 * wspd_850.max(), np.nan)\n\nCreate the Plot\n\nWith the data now ready, we will create the plot\n\n# Set up our projection\ncrs = ccrs.LambertConformal(central_longitude=-100.0, central_latitude=45.0)\n\n# Coordinates to limit map area\nbounds = [-122., -75., 25., 50.]\n\nPlot the composite\n\nfig = plt.figure(1, figsize=(17, 12))\nax = fig.add_subplot(1, 1, 1, projection=crs)\nax.set_extent(bounds, crs=ccrs.PlateCarree())\nax.coastlines('50m', edgecolor='black', linewidth=0.75)\nax.add_feature(cfeature.STATES, linewidth=0.25)\n\n# Plot Lifted Index\ncs1 = ax.contour(lon, lat, lifted_index, range(-8, -2, 2), transform=ccrs.PlateCarree(),\n                 colors='red', linewidths=0.75, linestyles='solid', zorder=7)\ncs1.clabel(fontsize=10, inline=1, inline_spacing=7,\n           fmt='%i', rightside_up=True, use_clabeltext=True)\n\n# Plot Surface pressure falls\ncs2 = ax.contour(lon, lat, pmsl_change.metpy.convert_units('hPa'), range(-10, -1, 4),\n                 transform=ccrs.PlateCarree(),\n                 colors='k', linewidths=0.75, linestyles='dashed', zorder=6)\ncs2.clabel(fontsize=10, inline=1, inline_spacing=7,\n           fmt='%i', rightside_up=True, use_clabeltext=True)\n\n# Plot 500-hPa height falls\ncs3 = ax.contour(lon, lat, hgt_500_change, range(-60, -29, 15),\n                 transform=ccrs.PlateCarree(), colors='k', linewidths=0.75,\n                 linestyles='solid', zorder=5)\ncs3.clabel(fontsize=10, inline=1, inline_spacing=7,\n           fmt='%i', rightside_up=True, use_clabeltext=True)\n\n# Plot surface pressure\nax.contourf(lon, lat, pmsl.metpy.convert_units('hPa'), range(990, 1011, 20), alpha=0.5,\n            transform=ccrs.PlateCarree(),\n            colors='yellow', zorder=1)\n\n# Plot surface dewpoint\nax.contourf(lon, lat, Td_sfc.metpy.convert_units('degF'), range(65, 76, 10), alpha=0.4,\n            transform=ccrs.PlateCarree(),\n            colors=['green'], zorder=2)\n\n# Plot 700-hPa dewpoint depression\nax.contourf(lon, lat, Td_dep_700, range(15, 46, 30), alpha=0.5, transform=ccrs.PlateCarree(),\n            colors='tan', zorder=3)\n\n# Plot Vorticity Advection\npurple = ax.contourf(lon, lat, vort_adv_500_smooth, range(5, 106, 100), alpha=0.5,\n            transform=ccrs.PlateCarree(),\n            colors='BlueViolet', zorder=4)\n\n# Define a skip to reduce the barb point density\nskip_300 = (slice(None, None, 12), slice(None, None, 12))\nskip_500 = (slice(None, None, 10), slice(None, None, 10))\nskip_850 = (slice(None, None, 8), slice(None, None, 8))\n\n# 300-hPa wind barbs\njet300 = ax.barbs(lon[skip_300].values, lat[skip_300].values,\n                  u_300_masked[skip_300].values, v_300_masked[skip_300].values,\n                  length=6,\n                  transform=ccrs.PlateCarree(),\n                  color='green', zorder=10, label='300-hPa Jet Core Winds (kt)')\n\n\n# 500-hPa wind barbs\njet500 = ax.barbs(lon[skip_500].values, lat[skip_500].values,\n                  u_500_masked[skip_500].values, v_500_masked[skip_500].values,\n                  length=6,\n                  transform=ccrs.PlateCarree(),\n                  color='blue', zorder=9, label='500-hPa Jet Core Winds (kt)')\n\n# 850-hPa wind barbs\njet850 = ax.barbs(lon[skip_850].values, lat[skip_850].values,\n                  u_850_masked[skip_850].values, v_850_masked[skip_850].values,\n                  length=6,\n                  transform=ccrs.PlateCarree(),\n                  color='k', zorder=8, label='850-hPa Jet Core Winds (kt)')\n\n# Legend\npurple = mpatches.Patch(color='BlueViolet', alpha=0.5, label='Cyclonic Absolute Vorticity Advection')\nyellow = mpatches.Patch(color='yellow', alpha=0.5, label='Surface MSLP < 1010 hPa')\ngreen = mpatches.Patch(color='green', alpha=0.5, label='Surface Td > 65 F')\ntan = mpatches.Patch(color='tan', alpha=0.5, label='700 hPa Dewpoint Depression > 15 C')\nred_line = lines.Line2D([], [], color='red', label='Best Lifted Index (C)')\ndashed_black_line = lines.Line2D([], [], linestyle='dashed', color='k',\n                                 label='12-hr Surface Pressure Falls (hPa)')\nblack_line = lines.Line2D([], [], linestyle='solid', color='k',\n                          label='12-hr 500-hPa Height Falls (m)')\nleg = plt.legend(handles=[jet300, jet500, jet850, dashed_black_line, black_line, red_line,\n                          purple, tan, green, yellow], loc=3,\n                 title=f'Composite Analysis Valid: {vtimes}',\n                 framealpha=1)\nleg.set_zorder(100)","type":"content","url":"/notebooks/convective/miller-composite","position":1},{"hierarchy":{"lvl1":"MetPy Declarative - 300 hPa"},"type":"lvl1","url":"/notebooks/declarative/declarative-300hpa","position":0},{"hierarchy":{"lvl1":"MetPy Declarative - 300 hPa"},"content":"By: Kevin Goebbert\n\nThis example uses the declarative syntax available through the MetPy\npackage to allow a more convenient method for creating simple maps of\natmospheric data. The key thing the declarative language does is to\nreduce the number of packages that users will need to know in detail and\ninstead allow them to set key parameters to get the map they desire. One\nkey element is the use of xarray as the data object, which allows\ncoordinate information to be associated with atmospheric variables.\n\nfrom datetime import datetime\n\nimport metpy.calc as mpcalc\nfrom metpy.plots.declarative import *\nfrom metpy.units import units\nimport xarray as xr\n\nOpen dataset using xarray module and subset global GFS to be over the\nCONUS.\n\nds = xr.open_dataset('https://thredds.ucar.edu/thredds/dodsC/casestudies'\n                     '/python-gallery/GFS_20101026_1200.nc').sel(\n    lon=slice(360-150, 360-50, 2), lat=slice(65, 20, 2))\n\n","type":"content","url":"/notebooks/declarative/declarative-300hpa","position":1},{"hierarchy":{"lvl1":"MetPy Declarative - 300 hPa","lvl2":"Calculate Variable and Add to Dataset"},"type":"lvl2","url":"/notebooks/declarative/declarative-300hpa#calculate-variable-and-add-to-dataset","position":2},{"hierarchy":{"lvl1":"MetPy Declarative - 300 hPa","lvl2":"Calculate Variable and Add to Dataset"},"content":"Here it is demonstrated how you can calculate a new variable and add it\nto the xarray dataset (ds) so that it can be plotted with the\ndeclarative syntax. The key to adding a variable to an xarray dataset\nfor use in the declarative syntax is the need to add a grid_mapping\nand units attribute.\n\n# Calculate New Variables and place into Xarray Dataset\nuwnd = ds['u-component_of_wind_isobaric']\nvwnd = ds['v-component_of_wind_isobaric']\n\n# Compute wind speed using MetPy\nwspd = mpcalc.wind_speed(uwnd, vwnd)\n\n# Place wind speed (wspd) into xarray dataset and attach needed attributes\nds['wind_speed'] = wspd\n\n","type":"content","url":"/notebooks/declarative/declarative-300hpa#calculate-variable-and-add-to-dataset","position":3},{"hierarchy":{"lvl1":"MetPy Declarative - 300 hPa","lvl2":"Declarative Plot"},"type":"lvl2","url":"/notebooks/declarative/declarative-300hpa#declarative-plot","position":4},{"hierarchy":{"lvl1":"MetPy Declarative - 300 hPa","lvl2":"Declarative Plot"},"content":"The following settings create a single panel map plot of 300 hPa\ngeopotential heights, wind speed, and wind barbs.\n\n# Countour Plot of Geopotential Heights\ncontour = ContourPlot()\ncontour.data = ds\ncontour.time = datetime(2010, 10, 31, 12)\ncontour.field = 'Geopotential_height_isobaric'\ncontour.level = 300 * units.hPa\ncontour.linecolor = 'black'\ncontour.linestyle = '-'\ncontour.linewidth = 2\ncontour.clabels = True\ncontour.contours = list(range(0, 20000, 120))\n\n# Colorfilled Plot of Wind Speed\ncfill = FilledContourPlot()\ncfill.data = ds\ncfill.field = 'wind_speed'\ncfill.level = 300 * units.hPa\ncfill.colormap = 'BuPu'\ncfill.contours = list(range(50, 171, 20))\ncfill.colorbar = 'vertical'\ncfill.plot_units = 'kt'\n\n# Plot wind barbs\nbarb = BarbPlot()\nbarb.data = ds\nbarb.level = 300 * units.hPa\nbarb.field = ['u-component_of_wind_isobaric', 'v-component_of_wind_isobaric']\nbarb.skip = (3, 3)\nbarb.color = 'black'\nbarb.barblength = 6.5\nbarb.earth_relative = False\nbarb.plot_units = 'kt'\n\n# Panel for plot with Map features\npanel = MapPanel()\npanel.layout = (1, 1, 1)\npanel.area = (-124, -72, 20, 53)\npanel.projection = 'lcc'\npanel.layers = ['coastline', 'borders', 'states', 'land']\npanel.plots = [cfill, contour, barb]\n\n# Bringing it all together\npc = PanelContainer()\npc.size = (15, 9)\npc.panels = [panel]\n\npc.show()","type":"content","url":"/notebooks/declarative/declarative-300hpa#declarative-plot","position":5},{"hierarchy":{"lvl1":"Declarative 500-hPa Absolute Vorticity"},"type":"lvl1","url":"/notebooks/declarative/declarative-500-hpa","position":0},{"hierarchy":{"lvl1":"Declarative 500-hPa Absolute Vorticity"},"content":"By: Kevin Goebbert\n\nThis example uses the declarative syntax available through the MetPy package to allow a more convenient method for creating simple maps of atmospheric data. To plot aboslute vorticity, the data is scaled and reassigned to the xarray object for use in the declarative plotting interface.\n\nfrom datetime import datetime\n\nimport xarray as xr\n\nfrom metpy.plots import declarative\nfrom metpy.units import units\n\n# Set date for desired dataset\ndt = datetime(2012, 10, 31, 12)\n\n# Open dataset from NCEI\nds = xr.open_dataset('https://www.ncei.noaa.gov/thredds/dodsC/'\n                     f'model-gfs-g4-anl-files-old/{dt:%Y%m}/{dt:%Y%m%d}/'\n                     f'gfsanl_4_{dt:%Y%m%d}_{dt:%H}00_000.grb2'\n                     ).metpy.parse_cf()\n\n# Subset Data to be just over CONUS\nds_us = ds.sel(lon=slice(360-160, 360-40), lat=slice(65, 10))\n\n","type":"content","url":"/notebooks/declarative/declarative-500-hpa","position":1},{"hierarchy":{"lvl1":"Declarative 500-hPa Absolute Vorticity","lvl2":"Contour Intervals"},"type":"lvl2","url":"/notebooks/declarative/declarative-500-hpa#contour-intervals","position":2},{"hierarchy":{"lvl1":"Declarative 500-hPa Absolute Vorticity","lvl2":"Contour Intervals"},"content":"Since absolute vorticity rarely goes below zero in the Northern Hemisphere, we can set up a list of contour levels that doesn’t include values near but greater than zero. The following code yields a list containing: [-8, -7, -6, -5, -4, -3, -2, -1, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45]\n\n# Absolute Vorticity colors\n# Use two different colormaps from matplotlib and combine into one color set\nclevs_500_avor = list(range(-8, 1, 1))+list(range(8, 46, 1))\n\n","type":"content","url":"/notebooks/declarative/declarative-500-hpa#contour-intervals","position":3},{"hierarchy":{"lvl1":"Declarative 500-hPa Absolute Vorticity","lvl2":"The Plot"},"type":"lvl2","url":"/notebooks/declarative/declarative-500-hpa#the-plot","position":4},{"hierarchy":{"lvl1":"Declarative 500-hPa Absolute Vorticity","lvl2":"The Plot"},"content":"Using the declarative interface in MetPy to plot the 500-hPa Geopotential Heights and Absolute Vorticity.\n\n# Set Contour Plot Parameters\ncontour = declarative.ContourPlot()\ncontour.data = ds_us\ncontour.time = dt\ncontour.field = 'Geopotential_height_isobaric'\ncontour.level = 500 * units.hPa\ncontour.linecolor = 'black'\ncontour.linestyle = '-'\ncontour.linewidth = 2\ncontour.clabels = True\ncontour.contours = list(range(0, 20000, 60))\n\n# Set Color-filled Contour Parameters\ncfill = declarative.FilledContourPlot()\ncfill.data = ds_us\ncfill.time = dt\ncfill.field = 'Absolute_vorticity_isobaric'\ncfill.level = 500 * units.hPa\ncfill.contours = clevs_500_avor\ncfill.colormap = 'PuOr_r'\ncfill.image_range = (-45, 45)\ncfill.colorbar = 'horizontal'\ncfill.scale = 1e5\n\n# Panel for plot with Map features\npanel = declarative.MapPanel()\npanel.layout = (1, 1, 1)\npanel.area = 'uslcc'\npanel.projection = 'area'\npanel.layers = ['coastline', 'states', 'borders']\npanel.layers_edgecolor = ['black', 'grey', 'black']\npanel.layers_linewidth = [1.25, .75, 1]\npanel.title = (f'{cfill.level} GFS Geopotential Heights'\n               f'and Absolute Vorticity at {dt}')\npanel.plots = [cfill, contour]\n\n# Bringing it all together\npc = declarative.PanelContainer()\npc.size = (15, 14)\npc.panels = [panel]\n\npc.show()","type":"content","url":"/notebooks/declarative/declarative-500-hpa#the-plot","position":5},{"hierarchy":{"lvl1":"MetPy’s Simplified Plotting Interface"},"type":"lvl1","url":"/notebooks/declarative","position":0},{"hierarchy":{"lvl1":"MetPy’s Simplified Plotting Interface"},"content":"TBD","type":"content","url":"/notebooks/declarative","position":1},{"hierarchy":{"lvl1":"How to Cite This Cookbook"},"type":"lvl1","url":"/notebooks/how-to-cite","position":0},{"hierarchy":{"lvl1":"How to Cite This Cookbook"},"content":"The material in Project Pythia’s Metpy Cookbook is licensed for free and open consumption and reuse. All code is served under \n\nApache 2.0, while all non-code content is licensed under \n\nCreative Commons BY 4.0 (CC BY 4.0). Effectively, this means you are free to share and adapt this material so long as you give appropriate credit to the Cookbook authors and the Project Pythia community.\n\nThe source code for the book is \n\nreleased on GitHub and archived on Zenodo. This DOI will always resolve to the latest release of the book source:\n\n","type":"content","url":"/notebooks/how-to-cite","position":1},{"hierarchy":{"lvl1":"Advanced Sounding"},"type":"lvl1","url":"/notebooks/skewt/advanced-sounding","position":0},{"hierarchy":{"lvl1":"Advanced Sounding"},"content":"Plot a sounding using MetPy with more advanced features. This will use the same formatting and another dataset from MetPy’s sample data.\n\nNew additions\n\nLifted condensation level calculation (LCL)\n\nSurface based parcel profile\n\nConvective Available Potential Energy (CAPE) and Convective Inhibition (CIN) shaded\n\n0 degree isotherm distinguished\n\n","type":"content","url":"/notebooks/skewt/advanced-sounding","position":1},{"hierarchy":{"lvl1":"Advanced Sounding","lvl2":"Imports"},"type":"lvl2","url":"/notebooks/skewt/advanced-sounding#imports","position":2},{"hierarchy":{"lvl1":"Advanced Sounding","lvl2":"Imports"},"content":"\n\nimport matplotlib.pyplot as plt\nimport numpy as np\nimport pandas as pd\n\nimport metpy.calc as mpcalc\nfrom metpy.cbook import get_test_data\nfrom metpy.plots import add_metpy_logo, SkewT\nfrom metpy.units import units\n\n","type":"content","url":"/notebooks/skewt/advanced-sounding#imports","position":3},{"hierarchy":{"lvl1":"Advanced Sounding","lvl2":"Obtain Data and Format"},"type":"lvl2","url":"/notebooks/skewt/advanced-sounding#obtain-data-and-format","position":4},{"hierarchy":{"lvl1":"Advanced Sounding","lvl2":"Obtain Data and Format"},"content":"\n\nUpper air data can be obtained using the siphon package, but for this example we will use some of MetPy’s sample data.\nas_file_obj=False), skiprows=5, usecols=[0, 1, 2, 3, 6, 7], names=col_names) is necessary due to the formatting of the MetPy sample data. This formatting is not needed when using upper air data obtained via Siphon. Obtaining data with Siphon will be covered in a later notebook.\n\ncol_names = ['pressure', 'height', 'temperature', 'dewpoint', 'direction', 'speed']\n\nsounding_data = pd.read_fwf(get_test_data('may4_sounding.txt', as_file_obj=False),\n                 skiprows=5, usecols=[0, 1, 2, 3, 6, 7], names=col_names)\n\n# Drop any rows with all not a number (NaN) values for temperature, dewpoint, and winds\nsounding_data = sounding_data.dropna(subset=('temperature', 'dewpoint', 'direction', 'speed'\n                       ), how='all').reset_index(drop=True)\n\n","type":"content","url":"/notebooks/skewt/advanced-sounding#obtain-data-and-format","position":5},{"hierarchy":{"lvl1":"Advanced Sounding","lvl2":"Assign Units"},"type":"lvl2","url":"/notebooks/skewt/advanced-sounding#assign-units","position":6},{"hierarchy":{"lvl1":"Advanced Sounding","lvl2":"Assign Units"},"content":"\n\nWe will pull the data out of the example dataset into individual variables and assign units. This is explained in further detail in the Simple Sounding notebook and in the \n\nMetpy documentation.\n\npres = sounding_data['pressure'].values * units.hPa\ntemp = sounding_data['temperature'].values * units.degC\ndewpoint = sounding_data['dewpoint'].values * units.degC\nwind_speed = sounding_data['speed'].values * units.knots\nwind_dir = sounding_data['direction'].values * units.degrees\nu, v = mpcalc.wind_components(wind_speed, wind_dir)\n\n","type":"content","url":"/notebooks/skewt/advanced-sounding#assign-units","position":7},{"hierarchy":{"lvl1":"Advanced Sounding","lvl2":"Create Sounding Plot"},"type":"lvl2","url":"/notebooks/skewt/advanced-sounding#create-sounding-plot","position":8},{"hierarchy":{"lvl1":"Advanced Sounding","lvl2":"Create Sounding Plot"},"content":"\n\n# Create figure and set size\nfig = plt.figure(figsize=(9, 9))\nskew = SkewT(fig, rotation=45)\n\n# Plot temperature, dewpoint and wind barbs\nskew.plot(pres, temp, 'red')\nskew.plot(pres, dewpoint, 'green')\n\n# Plot wind barbs\nmy_interval = np.arange(100, 1000, 50) * units('hPa') #set spacing interval\nix = mpcalc.resample_nn_1d(pres, my_interval) #find nearest indices for chosen interval\nskew.plot_barbs(pres[ix], u[ix], v[ix], xloc=1) #plot values closest to chosen interval\n\n# Improve labels and set axis limits\nskew.ax.set_xlabel('Temperature (\\N{DEGREE CELSIUS})')\nskew.ax.set_ylabel('Pressure (hPa)')\nskew.ax.set_ylim(1000, 100)\nskew.ax.set_xlim(-40, 59)\n\n# Calculate LCL height and plot as black dot.\nlcl_pressure, lcl_temperature = mpcalc.lcl(pres[0], temp[0], dewpoint[0]) #index 0 is chosen to lift parcel from the surface\nskew.plot(lcl_pressure, lcl_temperature, 'ko', markerfacecolor='black')\n\n# Calculate full parcel profile and add to plot as black line\nprof = mpcalc.parcel_profile(pres, temp[0], dewpoint[0]).to('degC')\nskew.plot(pres, prof, 'black', linewidth=2)\n\n# Shade areas of CAPE and CIN\nskew.shade_cin(pres, temp, prof, dewpoint)\nskew.shade_cape(pres, temp, prof)\n\n# Add emphasis to 0 degree isotherm with color change\nskew.ax.axvline(0, color='c', linestyle='--', linewidth=2)\n\n# Add the relevant special lines throughout the figure\nskew.plot_dry_adiabats(t0=np.arange(233, 533, 15) * units.K, alpha=0.25, color='orangered')\nskew.plot_moist_adiabats(t0=np.arange(233, 400, 10) * units.K, alpha=0.25, color='tab:green')\nskew.plot_mixing_lines(pressure=np.arange(1000, 99, -25) * units.hPa, linestyle='dotted', color='tab:blue')\n\n# Add the MetPy logo!\nfig = plt.gcf()\nadd_metpy_logo(fig, 115, 100, size='small');\n\n# Add a title\nplt.title('Advanced Sounding');","type":"content","url":"/notebooks/skewt/advanced-sounding#create-sounding-plot","position":9},{"hierarchy":{"lvl1":"MetPy Skew-T Cookbook"},"type":"lvl1","url":"/notebooks/skewt/foundational-sounding","position":0},{"hierarchy":{"lvl1":"MetPy Skew-T Cookbook"},"content":"","type":"content","url":"/notebooks/skewt/foundational-sounding","position":1},{"hierarchy":{"lvl1":"MetPy Skew-T Cookbook","lvl3":"Overview"},"type":"lvl3","url":"/notebooks/skewt/foundational-sounding#overview","position":2},{"hierarchy":{"lvl1":"MetPy Skew-T Cookbook","lvl3":"Overview"},"content":"This Project Pythia Cookbook will cover creating Skew-T plots with MetPy. \n\nIn this Cookbook, you will learn:\n\nThe foundations of creating a basic Skew-T with MetPy.\n\nAdding advanced features to a Skew-T such as Convective Available Potential Energy (CAPE) and Convective Inhibition (CIN) shading, Lifted condensation Level marker (LCL) and parcel profile.\n\nCreating a Hodograph with multiple layout options.\n\nAccessing remote Upper Air data with Siphon from University of Wyoming and Iowa State University.\n\nUsing MetPy to calculate several Skew-T parameters.\n\n","type":"content","url":"/notebooks/skewt/foundational-sounding#overview","position":3},{"hierarchy":{"lvl1":"MetPy Skew-T Cookbook","lvl3":"Prerequisites"},"type":"lvl3","url":"/notebooks/skewt/foundational-sounding#prerequisites","position":4},{"hierarchy":{"lvl1":"MetPy Skew-T Cookbook","lvl3":"Prerequisites"},"content":"Concepts\n\nImportance\n\nNotes\n\nIntermediate NumPy\n\nNecessary\n\n\n\nMatplotlib Basics\n\nNecessary\n\n\n\nTime to learn: 30 minutes\n\n\n\n","type":"content","url":"/notebooks/skewt/foundational-sounding#prerequisites","position":5},{"hierarchy":{"lvl1":"MetPy Skew-T Cookbook","lvl3":"Imports"},"type":"lvl3","url":"/notebooks/skewt/foundational-sounding#imports","position":6},{"hierarchy":{"lvl1":"MetPy Skew-T Cookbook","lvl3":"Imports"},"content":"\n\nimport matplotlib.pyplot as plt\nimport numpy as np\nimport pandas as pd\n\nimport metpy.calc as mpcalc\nfrom metpy.cbook import get_test_data\nfrom metpy.plots import add_metpy_logo, SkewT\nfrom metpy.units import units\n\n","type":"content","url":"/notebooks/skewt/foundational-sounding#imports","position":7},{"hierarchy":{"lvl1":"MetPy Skew-T Cookbook","lvl2":"Simple Sounding with MetPy Test Data"},"type":"lvl2","url":"/notebooks/skewt/foundational-sounding#simple-sounding-with-metpy-test-data","position":8},{"hierarchy":{"lvl1":"MetPy Skew-T Cookbook","lvl2":"Simple Sounding with MetPy Test Data"},"content":"Use MetPy to make a simple Skew-T plot. This will serve as a base for all Skew-T plots throughout this cookbook. \n\n","type":"content","url":"/notebooks/skewt/foundational-sounding#simple-sounding-with-metpy-test-data","position":9},{"hierarchy":{"lvl1":"MetPy Skew-T Cookbook","lvl3":"Obtain Data and Format","lvl2":"Simple Sounding with MetPy Test Data"},"type":"lvl3","url":"/notebooks/skewt/foundational-sounding#obtain-data-and-format","position":10},{"hierarchy":{"lvl1":"MetPy Skew-T Cookbook","lvl3":"Obtain Data and Format","lvl2":"Simple Sounding with MetPy Test Data"},"content":"\n\nUpper air data can be obtained using the siphon package, but for this example we will use some of MetPy’s sample data.\nas_file_obj=False), skiprows=5, usecols=[0, 1, 2, 3, 6, 7], names=col_names) is necessary due to the formatting of the MetPy sample data. This formatting is not needed when using upper air data obtained via Siphon. Obtaining data with Siphon will be covered in a later notebook.\n\ncol_names = ['pressure', 'height', 'temperature', 'dewpoint', 'direction', 'speed']\n\nsounding_data= pd.read_fwf(get_test_data('jan20_sounding.txt', as_file_obj=False),\n                 skiprows=5, usecols=[0, 1, 2, 3, 6, 7], names=col_names)\n\n# Drop any rows with all not a number (NaN) values for temperature, dewpoint, and winds\nsounding_data = sounding_data.dropna(subset=('temperature', 'dewpoint', 'direction', 'speed'\n                       ), how='all').reset_index(drop=True)\n\nsounding_data.head()\n\n","type":"content","url":"/notebooks/skewt/foundational-sounding#obtain-data-and-format","position":11},{"hierarchy":{"lvl1":"MetPy Skew-T Cookbook","lvl3":"Assign Units","lvl2":"Simple Sounding with MetPy Test Data"},"type":"lvl3","url":"/notebooks/skewt/foundational-sounding#assign-units","position":12},{"hierarchy":{"lvl1":"MetPy Skew-T Cookbook","lvl3":"Assign Units","lvl2":"Simple Sounding with MetPy Test Data"},"content":"\n\nOne of MetPy’s powerful features is its unit syntax. MetPy typically requires units to be attached to arrays before being passed to MetPy functions. The MetPy documentation has a full tutorial section on \n\nworking with units. \n\nIn order to plot our sounding data, we will need to pass units to the individual variables in our dataset.\n\npres = sounding_data['pressure'].values * units.hPa\ntemp = sounding_data['temperature'].values * units.degC\ndewpoint = sounding_data['dewpoint'].values * units.degC\nwind_speed = sounding_data['speed'].values * units.knots\nwind_dir = sounding_data['direction'].values * units.degrees\nu, v = mpcalc.wind_components(wind_speed, wind_dir)\n\npres\n\n","type":"content","url":"/notebooks/skewt/foundational-sounding#assign-units","position":13},{"hierarchy":{"lvl1":"MetPy Skew-T Cookbook","lvl3":"Create Sounding Plot","lvl2":"Simple Sounding with MetPy Test Data"},"type":"lvl3","url":"/notebooks/skewt/foundational-sounding#create-sounding-plot","position":14},{"hierarchy":{"lvl1":"MetPy Skew-T Cookbook","lvl3":"Create Sounding Plot","lvl2":"Simple Sounding with MetPy Test Data"},"content":"\n\n# Create figure and set size\nfig = plt.figure(figsize=(9, 9))\nskew = SkewT(fig, rotation=45)\n\n# Plot temperature and dewpoint lines\nskew.plot(pres, temp, 'red')\nskew.plot(pres, dewpoint, 'green')\n\n# Plot wind barbs\nskew.plot_barbs(pres, u, v)\n\n# Improve labels and set axis limits\nskew.ax.set_xlabel('Temperature (\\N{DEGREE CELSIUS})')\nskew.ax.set_ylabel('Pressure (hPa)')\nskew.ax.set_ylim(1000, 100)\n\n# Add the relevant special lines\nskew.plot_dry_adiabats()\nskew.plot_moist_adiabats()\nskew.plot_mixing_lines()\n\n# Add the MetPy logo!\nfig = plt.gcf()\nadd_metpy_logo(fig, 115, 100, size='small');\n\n# Add a title\nplt.title('Simple Sounding');\n\n","type":"content","url":"/notebooks/skewt/foundational-sounding#create-sounding-plot","position":15},{"hierarchy":{"lvl1":"MetPy Skew-T Cookbook","lvl4":"Let’s Unpack the the Previous Code Cell","lvl3":"Create Sounding Plot","lvl2":"Simple Sounding with MetPy Test Data"},"type":"lvl4","url":"/notebooks/skewt/foundational-sounding#lets-unpack-the-the-previous-code-cell","position":16},{"hierarchy":{"lvl1":"MetPy Skew-T Cookbook","lvl4":"Let’s Unpack the the Previous Code Cell","lvl3":"Create Sounding Plot","lvl2":"Simple Sounding with MetPy Test Data"},"content":"\n\nfig = plt.figure(figsize=(6, 6)) \n\nThis line creates the figure and sets the size. Equal proportions are typically recommended for a Skew-T. \n\nskew = SkewT(fig, rotation=45) \n\nCalls the MetPy \n\nSkew-T function to create a figure that we can easily plot upper air data on. Rotation is set at 45 to create the characteristic skewed appearence of a Skew-T.\n\nskew.plot(pres, temp, 'red') \nskew.plot(pres, dewpoint, 'green') \n\nThese two lines plot the \n\ntemperature and dewpoint lines. The lines are set to the standard colors, but can be adjusted for colorblind accessibility. Matplotlib has extensive \n\ndocumentation on choosing colormaps and color vision deficiencies resources.\n\nskew.plot_barbs(pres, u, v)\n\nThis line plots the wind barbs. Customization options can be found \n\nhere.\n\nskew.ax.set_xlabel('Temperature (\\N{DEGREE CELSIUS})') \nskew.ax.set_ylabel('Pressure (hPa)') \nskew.ax.set_ylim(1000, 100) \n\nThese lines improve the axes labels and set the y-axis limit to the standard values typically used in a Skew-T diagram.\n\n\nskew.plot_dry_adiabats()\nskew.plot_moist_adiabats()\nskew.plot_mixing_lines()\n\nThese add each relevant special line if desired. The argument colors='preferred color here' can be passed if you would like to change the colors from the default. Further customization options can be found in the MetPy \n\ndocumentation for each line.\n\nfig = plt.gcf()\n\nGcf stands for get current figure. This retrieves the current figure and allows us to modify it with the following line. \n\nadd_metpy_logo(fig, 115, 100)\n\nWhen add_metpy_logo is included in the imports cell, it allows use of the add_metpy_logo() function. This is greatly appreciated when utilizing MetPy for your plots. The \n\nposition and size of the logo can be adjusted.\n\n\nplt.title('Simple Sounding');\n\nThis adds the title to the figure. The ; removes text that populates above the figure.\n\n\n","type":"content","url":"/notebooks/skewt/foundational-sounding#lets-unpack-the-the-previous-code-cell","position":17},{"hierarchy":{"lvl1":"MetPy Skew-T Cookbook","lvl3":"Now, Let’s Improve the Wind Barbs","lvl2":"Simple Sounding with MetPy Test Data"},"type":"lvl3","url":"/notebooks/skewt/foundational-sounding#now-lets-improve-the-wind-barbs","position":18},{"hierarchy":{"lvl1":"MetPy Skew-T Cookbook","lvl3":"Now, Let’s Improve the Wind Barbs","lvl2":"Simple Sounding with MetPy Test Data"},"content":"We will use the same code as above, but will add three additional lines of code.\n\n# Create figure and set size\nfig = plt.figure(figsize=(9, 9))\nskew = SkewT(fig, rotation=45)\n\n# Plot temperature and dewpoint lines\nskew.plot(pres, temp, 'red')\nskew.plot(pres, dewpoint, 'green')\n\n# Set spacing interval--Every 50 hPa from 1000 to 100 hPa\nmy_interval = np.arange(100, 1000, 50) * units('hPa')\n\n# Get indexes of values closest to chosen interval\nix = mpcalc.resample_nn_1d(pres, my_interval)\n\n# Plot wind barbs with values nearest to chosen interval values\nskew.plot_barbs(pres[ix], u[ix], v[ix])\n\n# Improve labels and set axis limits\nskew.ax.set_xlabel('Temperature (\\N{DEGREE CELSIUS})')\nskew.ax.set_ylabel('Pressure (hPa)')\nskew.ax.set_ylim(1000, 100)\n\n# Add the relevant special lines\nskew.plot_dry_adiabats()\nskew.plot_moist_adiabats()\nskew.plot_mixing_lines()\n\n# Add the MetPy logo!\nfig = plt.gcf()\nadd_metpy_logo(fig, 115, 100, size='small');\n\n# Add a title\nplt.title('Simple Sounding');\n\nThe wind barbs on this plot are much more readable. Let’s review the added code to understand why.\n\nmy_interval = np.arange(100, 1000, 50) * units('hPa')\n\nThis creates a custom spacing interval from the pressure levels the wind barbs are plotted on.\n\nix = mpcalc.resample_nn_1d(pres, my_interval)\n\nWe defined where we want the wind barbs with my_interval. Since mb is not an index in our dataset, we have to use the function mpcalc.resample_nn_1d() to determine what index value each interval closest matches up with. Further information can be found in the MetPy \n\ndocumentation.\n\nskew.plot_barbs(pres[ix], u[ix], v[ix])\n\nNow we just add the ix variable to each parameter in .plot_barbs() to produce the wind barbs at the interval we set.\n\n","type":"content","url":"/notebooks/skewt/foundational-sounding#now-lets-improve-the-wind-barbs","position":19},{"hierarchy":{"lvl1":"MetPy Skew-T Cookbook","lvl3":"Optional Step","lvl2":"Simple Sounding with MetPy Test Data"},"type":"lvl3","url":"/notebooks/skewt/foundational-sounding#optional-step","position":20},{"hierarchy":{"lvl1":"MetPy Skew-T Cookbook","lvl3":"Optional Step","lvl2":"Simple Sounding with MetPy Test Data"},"content":"We can extend the moist adiabat, dry adiabat, and mixing ratio lines throughout the figure by adding including optional parameters. See the \n\ndocumentation for details on how to further adjust these for readability preferences.\n\n# Create figure and set size\nfig = plt.figure(figsize=(9, 9))\nskew = SkewT(fig, rotation=45)\n\n# Plot temperature and dewpoint lines\nskew.plot(pres, temp, 'red')\nskew.plot(pres, dewpoint, 'green')\n\n# Set spacing interval--Every 50 hPa from 1000 to 100 hPa\nmy_interval = np.arange(100, 1000, 50) * units('hPa')\n\n# Get indexes of values closest to chosen interval\nix = mpcalc.resample_nn_1d(pres, my_interval)\n\n# Plot wind barbs with values nearest to chosen interval values\nskew.plot_barbs(pres[ix], u[ix], v[ix])\n\n# Improve labels and set axis limits\nskew.ax.set_xlabel('Temperature (\\N{DEGREE CELSIUS})')\nskew.ax.set_ylabel('Pressure (hPa)')\nskew.ax.set_ylim(1000, 100)\n\n# Add the relevant special lines\nskew.plot_dry_adiabats(t0=np.arange(233, 533, 10) * units.K, alpha=0.25, color='orangered')\nskew.plot_moist_adiabats(t0=np.arange(233, 400, 5) * units.K, alpha=0.25, color='tab:green')\nskew.plot_mixing_lines(pressure=np.arange(1000, 99, -25) * units.hPa, linestyle='dotted', color='tab:blue')\n\n# Add the MetPy logo!\nfig = plt.gcf()\nadd_metpy_logo(fig, 115, 100, size='small');\n\n# Add a title\nplt.title('Simple Sounding');\n\n","type":"content","url":"/notebooks/skewt/foundational-sounding#optional-step","position":21},{"hierarchy":{"lvl1":"MetPy Skew-T Cookbook","lvl3":"Resources and references","lvl2":"Simple Sounding with MetPy Test Data"},"type":"lvl3","url":"/notebooks/skewt/foundational-sounding#resources-and-references","position":22},{"hierarchy":{"lvl1":"MetPy Skew-T Cookbook","lvl3":"Resources and references","lvl2":"Simple Sounding with MetPy Test Data"},"content":"MetPy Documentation \n\n\nUnidata Main Website \n\n\nUnidata GitHub \n\n\nUnidata YouTube Channel \n\n\nMatplotlib Documentation ","type":"content","url":"/notebooks/skewt/foundational-sounding#resources-and-references","position":23},{"hierarchy":{"lvl1":"Skew-T Analysis"},"type":"lvl1","url":"/notebooks/skewt/skew-t-analysis","position":0},{"hierarchy":{"lvl1":"Skew-T Analysis"},"content":"Create a Skew-T plot using remote data from University of Wyoming.\n\nThis example uses example data from the University of Wyoming sounding\narchive for 12 UTC 31 October 2016 for Minneapolis, MN (MPX).\n\n","type":"content","url":"/notebooks/skewt/skew-t-analysis","position":1},{"hierarchy":{"lvl1":"Skew-T Analysis","lvl2":"Imports"},"type":"lvl2","url":"/notebooks/skewt/skew-t-analysis#imports","position":2},{"hierarchy":{"lvl1":"Skew-T Analysis","lvl2":"Imports"},"content":"\n\nimport matplotlib.pyplot as plt\nimport numpy as np\nimport pandas as pd\n\nimport metpy.calc as mpcalc\nfrom metpy.cbook import get_test_data\nfrom metpy.plots import add_metpy_logo, SkewT\nfrom metpy.units import units\n\nfrom datetime import datetime\nfrom siphon.simplewebservice.wyoming import WyomingUpperAir\n\n","type":"content","url":"/notebooks/skewt/skew-t-analysis#imports","position":3},{"hierarchy":{"lvl1":"Skew-T Analysis","lvl2":"Obtain Data and Format"},"type":"lvl2","url":"/notebooks/skewt/skew-t-analysis#obtain-data-and-format","position":4},{"hierarchy":{"lvl1":"Skew-T Analysis","lvl2":"Obtain Data and Format"},"content":"This requires an internet connection to access the sounding data from a\nremote server at the University of Wyoming. \n\nFirst we will create variables for date, time and station. \nFormat: datetime(YYYY, MM, DD, HH) \n\nThe station entry will need the be the three letter identifier of the station you want to look at. The National Center for Atmospheric Research (NCAR) \n\nResearch Applications Labratory (RAL) continously updates a \n\ndetailed list of all stations.\n\n# Create variables for preferred date, time and station\npreferred_date = datetime(2016, 10, 26, 12)\nstation = 'MPX'\n\n# Read remote sounding data based on preferred_date and station\nsounding_data = WyomingUpperAir.request_data(preferred_date, station)\n\nsounding_data\n\n","type":"content","url":"/notebooks/skewt/skew-t-analysis#obtain-data-and-format","position":5},{"hierarchy":{"lvl1":"Skew-T Analysis","lvl2":"Assign Units"},"type":"lvl2","url":"/notebooks/skewt/skew-t-analysis#assign-units","position":6},{"hierarchy":{"lvl1":"Skew-T Analysis","lvl2":"Assign Units"},"content":"\n\nWe will pull the data out of the example dataset into individual variables and assign units. This is explained in further detain in the Simple Sounding notebook and in the \n\nMetpy documentation.\n\npres = sounding_data['pressure'].values * units.hPa\ntemp = sounding_data['temperature'].values * units.degC\ndewpoint = sounding_data['dewpoint'].values * units.degC\nwind_speed = sounding_data['speed'].values * units.knots\nwind_dir = sounding_data['direction'].values * units.degrees\nu = sounding_data['u_wind'].values * units.knots\nv = sounding_data['v_wind'].values * units.knots\n\n","type":"content","url":"/notebooks/skewt/skew-t-analysis#assign-units","position":7},{"hierarchy":{"lvl1":"Skew-T Analysis","lvl2":"Create Sounding Plot"},"type":"lvl2","url":"/notebooks/skewt/skew-t-analysis#create-sounding-plot","position":8},{"hierarchy":{"lvl1":"Skew-T Analysis","lvl2":"Create Sounding Plot"},"content":"\n\n# Create figure and set size\nfig = plt.figure(figsize=(9, 9))\nskew = SkewT(fig, rotation=45)\n\n# Plot temperature and dewpoint lines\nskew.plot(pres, temp, 'red')\nskew.plot(pres, dewpoint, 'green')\n\n# Plot wind barbs\nmy_interval = np.arange(100, 1000, 25) * units('hPa')\nix = mpcalc.resample_nn_1d(pres, my_interval)\nskew.plot_barbs(pres[ix], u[ix], v[ix], y_clip_radius=0.001)\n\n# Improve labels and set axis limits\nskew.ax.set_xlabel('Temperature (\\N{DEGREE CELSIUS})')\nskew.ax.set_ylabel('Pressure (hPa)')\nskew.ax.set_ylim(1000, 100)\n\n# Add the relevant special lines\nskew.plot_dry_adiabats(t0=np.arange(233, 533, 10) * units.K, alpha=0.25, color='orangered')\nskew.plot_moist_adiabats(t0=np.arange(233, 400, 5) * units.K, alpha=0.25, color='tab:green')\nskew.plot_mixing_lines(pressure=np.arange(1000, 99, -25) * units.hPa, linestyle='dotted', color='tab:blue')\n\n# Add the MetPy logo!\nfig = plt.gcf()\nadd_metpy_logo(fig, 115, 100, size='small');\n\n# Add some descriptive titles\nplt.title('{} Sounding'.format(station), loc='left')\nplt.title('Valid Time: {}'.format(preferred_date), loc='right');","type":"content","url":"/notebooks/skewt/skew-t-analysis#create-sounding-plot","position":9},{"hierarchy":{"lvl1":"Hodograph Inset"},"type":"lvl1","url":"/notebooks/skewt/skew-t-hodograph-inset","position":0},{"hierarchy":{"lvl1":"Hodograph Inset"},"content":"Layout a Skew-T plot with a hodograph inset into the plot.\n\n","type":"content","url":"/notebooks/skewt/skew-t-hodograph-inset","position":1},{"hierarchy":{"lvl1":"Hodograph Inset","lvl2":"Imports"},"type":"lvl2","url":"/notebooks/skewt/skew-t-hodograph-inset#imports","position":2},{"hierarchy":{"lvl1":"Hodograph Inset","lvl2":"Imports"},"content":"\n\nimport matplotlib.pyplot as plt\nimport numpy as np\nimport pandas as pd\n\nimport metpy.calc as mpcalc\nfrom metpy.cbook import get_test_data\nfrom metpy.plots import add_metpy_logo, Hodograph, SkewT\nfrom metpy.units import units\n\nfrom mpl_toolkits.axes_grid1.inset_locator import inset_axes\n\n","type":"content","url":"/notebooks/skewt/skew-t-hodograph-inset#imports","position":3},{"hierarchy":{"lvl1":"Hodograph Inset","lvl2":"Obtain Data and Format"},"type":"lvl2","url":"/notebooks/skewt/skew-t-hodograph-inset#obtain-data-and-format","position":4},{"hierarchy":{"lvl1":"Hodograph Inset","lvl2":"Obtain Data and Format"},"content":"\n\nUpper air data can be obtained using the siphon package, but for this example we will use some of MetPy’s sample data.\nas_file_obj=False), skiprows=5, usecols=[0, 1, 2, 3, 6, 7], names=col_names) is necessary due to the formatting of the MetPy sample data. This formatting is not needed when using upper air data obtained via Siphon. Obtaining data with Siphon will be covered in a later notebook.\n\ncol_names = ['pressure', 'height', 'temperature', 'dewpoint', 'direction', 'speed']\n\nsounding_data = pd.read_fwf(get_test_data('may4_sounding.txt', as_file_obj=False),\n                 skiprows=5, usecols=[0, 1, 2, 3, 6, 7], names=col_names)\n\n# Drop any rows with all not a number (NaN) values for temperature, dewpoint, and winds\nsounding_data = sounding_data.dropna(subset=('temperature', 'dewpoint', 'direction', 'speed'\n                       ), how='all').reset_index(drop=True)\n\n","type":"content","url":"/notebooks/skewt/skew-t-hodograph-inset#obtain-data-and-format","position":5},{"hierarchy":{"lvl1":"Hodograph Inset","lvl2":"Assign Units"},"type":"lvl2","url":"/notebooks/skewt/skew-t-hodograph-inset#assign-units","position":6},{"hierarchy":{"lvl1":"Hodograph Inset","lvl2":"Assign Units"},"content":"\n\nWe will pull the data out of the example dataset into individual variables and assign units. This is explained in further detain in the Simple Sounding notebook and in the \n\nMetpy documentation.\n\npres = sounding_data['pressure'].values * units.hPa\ntemp = sounding_data['temperature'].values * units.degC\ndewpoint = sounding_data['dewpoint'].values * units.degC\nwind_speed = sounding_data['speed'].values * units.knots\nwind_dir = sounding_data['direction'].values * units.degrees\nu, v = mpcalc.wind_components(wind_speed, wind_dir)\n\n# Create figure and grid for plots\nfig = plt.figure(figsize=(9, 9))\nskew = SkewT(fig, rotation=45)\n\n# Plot temperature and dewpoint lines\nskew.plot(pres, temp, 'red')\nskew.plot(pres, dewpoint, 'green')\n\n# Plot wind barbs\nmy_interval = np.arange(100, 1000, 50) * units('hPa')\nix = mpcalc.resample_nn_1d(pres, my_interval)\nskew.plot_barbs(pres[ix], u[ix], v[ix])\n\n# Improve labels and set axis limits\nskew.ax.set_xlabel('Temperature (\\N{DEGREE CELSIUS})')\nskew.ax.set_ylabel('Pressure (hPa)')\nskew.ax.set_ylim(1000, 100)\nskew.ax.set_xlim(-30, 40)\n\n# Add the relevant special lines\nskew.plot_dry_adiabats(t0=np.arange(233, 533, 10) * units.K, alpha=0.25, color='orangered')\nskew.plot_moist_adiabats(t0=np.arange(233, 400, 5) * units.K, alpha=0.25, color='tab:green')\nskew.plot_mixing_lines(pressure=np.arange(1000, 99, -25) * units.hPa, linestyle='dotted', color='tab:blue')\n\n# Create a hodograph\nax_hod = inset_axes(skew.ax, '35%', '35%', loc=1)\nh = Hodograph(ax_hod, component_range=80)\nh.add_grid(increment=20)\nh.plot_colormapped(u, v, pres)\n\n# Add the MetPy logo!\nfig = plt.gcf()\nadd_metpy_logo(fig, 110, 650, size='small');\n\n# Add title\nskew.ax.set_title('Advanced Sounding with Hodograph Inset');","type":"content","url":"/notebooks/skewt/skew-t-hodograph-inset#assign-units","position":7},{"hierarchy":{"lvl1":"Skew-T with Complex Layout"},"type":"lvl1","url":"/notebooks/skewt/skew-t-layout-hodograph","position":0},{"hierarchy":{"lvl1":"Skew-T with Complex Layout"},"content":"Combine a Skew-T and a hodograph using Matplotlib’s GridSpec layout capability.\n\n","type":"content","url":"/notebooks/skewt/skew-t-layout-hodograph","position":1},{"hierarchy":{"lvl1":"Skew-T with Complex Layout","lvl2":"Imports"},"type":"lvl2","url":"/notebooks/skewt/skew-t-layout-hodograph#imports","position":2},{"hierarchy":{"lvl1":"Skew-T with Complex Layout","lvl2":"Imports"},"content":"\n\nimport matplotlib.gridspec as gridspec\nimport matplotlib.pyplot as plt\nimport numpy as np\nimport pandas as pd\n\nimport metpy.calc as mpcalc\nfrom metpy.cbook import get_test_data\nfrom metpy.plots import add_metpy_logo, Hodograph, SkewT\nfrom metpy.units import units\n\n","type":"content","url":"/notebooks/skewt/skew-t-layout-hodograph#imports","position":3},{"hierarchy":{"lvl1":"Skew-T with Complex Layout","lvl2":"Obtain Data and Format"},"type":"lvl2","url":"/notebooks/skewt/skew-t-layout-hodograph#obtain-data-and-format","position":4},{"hierarchy":{"lvl1":"Skew-T with Complex Layout","lvl2":"Obtain Data and Format"},"content":"\n\nUpper air data can be obtained using the siphon package, but for this example we will use some of MetPy’s sample data.\nas_file_obj=False), skiprows=5, usecols=[0, 1, 2, 3, 6, 7], names=col_names) is necessary due to the formatting of the MetPy sample data. This formatting is not needed when using upper air data obtained via Siphon. Obtaining data with Siphon will be covered in a later notebook.\n\ncol_names = ['pressure', 'height', 'temperature', 'dewpoint', 'direction', 'speed']\n\nsounding_data = pd.read_fwf(get_test_data('may4_sounding.txt', as_file_obj=False),\n                 skiprows=5, usecols=[0, 1, 2, 3, 6, 7], names=col_names)\n\n# Drop any rows with all not a number (NaN) values for temperature, dewpoint, and winds\nsounding_data = sounding_data.dropna(subset=('temperature', 'dewpoint', 'direction', 'speed'\n                       ), how='all').reset_index(drop=True)\n\n","type":"content","url":"/notebooks/skewt/skew-t-layout-hodograph#obtain-data-and-format","position":5},{"hierarchy":{"lvl1":"Skew-T with Complex Layout","lvl2":"Assign Units"},"type":"lvl2","url":"/notebooks/skewt/skew-t-layout-hodograph#assign-units","position":6},{"hierarchy":{"lvl1":"Skew-T with Complex Layout","lvl2":"Assign Units"},"content":"\n\nWe will pull the data out of the example dataset into individual variables and assign units. This is explained in further detain in the Simple Sounding notebook and in the \n\nMetpy documentation.\n\npres = sounding_data['pressure'].values * units.hPa\ntemp = sounding_data['temperature'].values * units.degC\ndewpoint = sounding_data['dewpoint'].values * units.degC\nwind_speed = sounding_data['speed'].values * units.knots\nwind_dir = sounding_data['direction'].values * units.degrees\nu, v = mpcalc.wind_components(wind_speed, wind_dir)\n\n","type":"content","url":"/notebooks/skewt/skew-t-layout-hodograph#assign-units","position":7},{"hierarchy":{"lvl1":"Skew-T with Complex Layout","lvl2":"Create Sounding Plot"},"type":"lvl2","url":"/notebooks/skewt/skew-t-layout-hodograph#create-sounding-plot","position":8},{"hierarchy":{"lvl1":"Skew-T with Complex Layout","lvl2":"Create Sounding Plot"},"content":"\n\n# Create figure and grid for plots\ngs = gridspec.GridSpec(ncols=3, nrows=3)\nfig = plt.figure(figsize=(9, 9))\nskew = SkewT(fig, rotation=45, subplot=gs[:, :2])\n\n# Plot temperature and dewpoint lines\nskew.plot(pres, temp, 'red')\nskew.plot(pres, dewpoint, 'green')\n\n# Plot wind barbs\nmy_interval = np.arange(100, 1000, 50) * units('hPa')\nix = mpcalc.resample_nn_1d(pres, my_interval)\nskew.plot_barbs(pres[ix], u[ix], v[ix])\n\n# Improve labels and set axis limits\nskew.ax.set_xlabel('Temperature (\\N{DEGREE CELSIUS})')\nskew.ax.set_ylabel('Pressure (hPa)')\nskew.ax.set_ylim(1000, 100)\nskew.ax.set_xlim(-30, 40)\n\n# Add the relevant special lines\nskew.plot_dry_adiabats(t0=np.arange(233, 533, 10) * units.K, alpha=0.25, color='orangered')\nskew.plot_moist_adiabats(t0=np.arange(233, 400, 5) * units.K, alpha=0.25, color='tab:green')\nskew.plot_mixing_lines(pressure=np.arange(1000, 99, -25) * units.hPa, linestyle='dotted', color='tab:blue')\n\n# Create a hodograph \nax = fig.add_subplot(gs[0, -1])\nh = Hodograph(ax, component_range=80)\nh.add_grid(increment=20)\nh.plot_colormapped(u, v, pres)\nax.text(0.5, -0.15, 'knots', fontsize=8, ha='center', va='center', transform=ax.transAxes) #unit label\n\n# Add the MetPy logo!\nfig = plt.gcf()\nadd_metpy_logo(fig, 600, 70, size='large');\n\n# Add titles\nskew.ax.set_title('Advanced Sounding with Complex Layout', fontweight='bold', pad=10)\nax.set_title('Hodograph', fontsize=10);","type":"content","url":"/notebooks/skewt/skew-t-layout-hodograph#create-sounding-plot","position":9},{"hierarchy":{"lvl1":"Sounding Calculation Examples"},"type":"lvl1","url":"/notebooks/skewt/sounding-calculations","position":0},{"hierarchy":{"lvl1":"Sounding Calculation Examples"},"content":"Use functions from metpy.calc to perform a number of calculations using sounding data.\n\nThe code below uses example data to perform many sounding calculations for a severe weather\nevent on May 22, 2011 from the Norman, OK sounding.\n\n","type":"content","url":"/notebooks/skewt/sounding-calculations","position":1},{"hierarchy":{"lvl1":"Sounding Calculation Examples","lvl2":"Imports"},"type":"lvl2","url":"/notebooks/skewt/sounding-calculations#imports","position":2},{"hierarchy":{"lvl1":"Sounding Calculation Examples","lvl2":"Imports"},"content":"\n\nimport numpy as np\nimport pandas as pd\n\nimport metpy.calc as mpcalc\nfrom metpy.cbook import get_test_data\nfrom metpy.units import units\n\nEffective Shear Algorithm for use in Supercell Composite Calculation\n\ndef effective_layer(pressure, temperature, dewpoint, height, height_layer=False):\n    \"\"\"A function that determines the effective inflow layer for a convective sounding.\n\n    Uses the default values of Thompason et al. (2004) for CAPE (100 J/kg) and CIN (-250 J/kg).\n\n    Input:\n      - pressure: sounding pressure with units\n      - temperature: sounding temperature with units\n      - dewpoint: sounding dewpoint temperature with units\n      - height: sounding heights with units\n\n    Returns:\n      - pbot/hbot, ptop/htop: pressure/height of the bottom level,\n                              pressure/height of the top level\n    \"\"\"\n    from metpy.calc import cape_cin, parcel_profile\n    from metpy.units import units\n\n    pbot = None\n\n    for i in range(pressure.shape[0]):\n        prof = parcel_profile(pressure[i:], temperature[i], dewpoint[i])\n        sbcape, sbcin = cape_cin(pressure[i:], temperature[i:], dewpoint[i:], prof)\n        if sbcape >= 100 * units('J/kg') and sbcin > -250 * units('J/kg'):\n            pbot = pressure[i]\n            hbot = height[i]\n            bot_idx = i\n            break\n    if not pbot:\n        return None, None\n\n    for i in range(bot_idx + 1, pressure.shape[0]):\n        prof = parcel_profile(pressure[i:], temperature[i], dewpoint[i])\n        sbcape, sbcin = cape_cin(pressure[i:], temperature[i:], dewpoint[i:], prof)\n        if sbcape < 100 * units('J/kg') or sbcin < -250 * units('J/kg'):\n            ptop = pressure[i]\n            htop = height[i]\n            break\n\n    if height_layer:\n        return hbot, htop\n    else:\n        return pbot, ptop\n\n","type":"content","url":"/notebooks/skewt/sounding-calculations#imports","position":3},{"hierarchy":{"lvl1":"Sounding Calculation Examples","lvl2":"Obtain Data and Format"},"type":"lvl2","url":"/notebooks/skewt/sounding-calculations#obtain-data-and-format","position":4},{"hierarchy":{"lvl1":"Sounding Calculation Examples","lvl2":"Obtain Data and Format"},"content":"\n\nUpper air data can be obtained using the siphon package, but for this example we will use some of MetPy’s sample data.\nas_file_obj=False), skiprows=5, usecols=[0, 1, 2, 3, 6, 7], names=col_names) is necessary due to the formatting of the MetPy sample data. This formatting is not needed when using upper air data obtained via Siphon. Obtaining data with Siphon will be covered in a later notebook.\n\ncol_names = ['pressure', 'height', 'temperature', 'dewpoint', 'direction', 'speed']\n\nsounding_data = pd.read_fwf(get_test_data('20110522_OUN_12Z.txt', as_file_obj=False),\n                 skiprows=7, usecols=[0, 1, 2, 3, 6, 7], names=col_names)\n\n# Drop any rows with all not a number (NaN) values for temperature, dewpoint, and winds\nsounding_data = sounding_data.dropna(subset=('temperature', 'dewpoint', 'direction', 'speed'),\n               how='all').reset_index(drop=True)\n\n","type":"content","url":"/notebooks/skewt/sounding-calculations#obtain-data-and-format","position":5},{"hierarchy":{"lvl1":"Sounding Calculation Examples","lvl2":"Assign Units"},"type":"lvl2","url":"/notebooks/skewt/sounding-calculations#assign-units","position":6},{"hierarchy":{"lvl1":"Sounding Calculation Examples","lvl2":"Assign Units"},"content":"\n\nWe will pull the data out of the example dataset into individual variables and assign units. This is explained in further detain in the Simple Sounding notebook and in the \n\nMetpy documentation.\n\npres = sounding_data['pressure'].values * units.hPa\ntemp = sounding_data['temperature'].values * units.degC\ndewpoint = sounding_data['dewpoint'].values * units.degC\nwind_speed = sounding_data['speed'].values * units.knots\nwind_dir = sounding_data['direction'].values * units.degrees\nu, v = mpcalc.wind_components(wind_speed, wind_dir)\nheight = sounding_data['height'].values * units.meter\n\nCompute the wind components\n\nu, v = mpcalc.wind_components(wind_speed, wind_dir)\n\nCompute common sounding index parameters\n\nctotals = mpcalc.cross_totals(pres, temp, dewpoint)\nkindex = mpcalc.k_index(pres, temp, dewpoint)\nshowalter = mpcalc.showalter_index(pres, temp, dewpoint)\ntotal_totals = mpcalc.total_totals_index(pres, temp, dewpoint)\nvert_totals = mpcalc.vertical_totals(pres, temp)\n\nCompture the parcel profile for a surface-based parcel\n\nprof = mpcalc.parcel_profile(pres, temp[0], dewpoint[0])\n\nCompute the corresponding Lifted Index (LI), Convective Available Potential Energy (CAPE), Convective Inhibition (CIN) values for a surface parcel\n\nlift_index = mpcalc.lifted_index(pres, temp, prof)\ncape, cin = mpcalc.cape_cin(pres, temp, dewpoint, prof)\n\nDetermine the Lifted Condensation Level (LCL), Level of Free Convection (LFC), and Equilibrium Level (EL) for our surface parcel\n\nlclp, lclt = mpcalc.lcl(pres[0], temp[0], dewpoint[0])\nlfcp, _ = mpcalc.lfc(pres, temp, dewpoint)\nel_pressure, _ = mpcalc.el(pres, temp, dewpoint, prof)\n\nCompute the characteristics of a mean layer parcel (50-hPa depth)\n\nml_t, ml_td = mpcalc.mixed_layer(pres, temp, dewpoint, depth=50 * units.hPa)\nml_p, _, _ = mpcalc.mixed_parcel(pres, temp, dewpoint, depth=50 * units.hPa)\nmlcape, mlcin = mpcalc.mixed_layer_cape_cin(pres, temp, prof, depth=50 * units.hPa)\n\nCompute the characteristics of the most unstable parcel (50-hPa depth)\n\nmu_p, mu_t, mu_td, _ = mpcalc.most_unstable_parcel(pres, temp, dewpoint, depth=50 * units.hPa)\nmucape, mucin = mpcalc.most_unstable_cape_cin(pres, temp, dewpoint, depth=50 * units.hPa)\n\nCompute the Bunkers Storm Motion vector and use to calculate the critical angle\n\n(u_storm, v_storm), *_ = mpcalc.bunkers_storm_motion(pres, u, v, height)\ncritical_angle = mpcalc.critical_angle(pres, u, v, height, u_storm, v_storm)\n\nWork on the calculations needed to compute the significant tornado parameter\n\n# Estimate height of LCL in meters from hydrostatic thickness\nnew_p = np.append(pres[pres > lclp], lclp)\nnew_t = np.append(temp[pres > lclp], lclt)\nlcl_height = mpcalc.thickness_hydrostatic(new_p, new_t)\n\n# Compute Surface-based CAPE\nsbcape, _ = mpcalc.surface_based_cape_cin(pres, temp, dewpoint)\n\n# Compute SRH, given a motion vector toward the NE at 9.9 m/s\n*_, total_helicity = mpcalc.storm_relative_helicity(height, u, v, depth=1 * units.km,\n                                                    storm_u=u_storm, storm_v=v_storm)\n\n# Copmute Bulk Shear components and then magnitude\nubshr, vbshr = mpcalc.bulk_shear(pres, u, v, height=height, depth=6 * units.km)\nbshear = mpcalc.wind_speed(ubshr, vbshr)\n\n# Use all computed pieces to calculate the Significant Tornado parameter\nsig_tor = mpcalc.significant_tornado(sbcape, lcl_height,\n                                     total_helicity, bshear).to_base_units()\n\nCompute the supercell composite parameter, if possible\n\n# Determine the top and bottom of the effective layer using our own function\nhbot, htop = effective_layer(pres, temp, dewpoint, height, height_layer=True)\n\n# Perform the calculation of supercell composite if an effective layer exists\nif hbot:\n    esrh = mpcalc.storm_relative_helicity(height, u, v, depth=htop - hbot, bottom=hbot)\n    eubshr, evbshr = mpcalc.bulk_shear(pres, u, v, height=height, depth=htop - hbot, bottom=hbot)\n    ebshear = mpcalc.wind_speed(eubshr, evbshr)\n\n    super_comp = mpcalc.supercell_composite(mucape, esrh[0], ebshear)\nelse:\n    super_comp = np.nan\n\nPrint Important Sounding Parameters\n\nprint('Important Sounding Parameters for KOUN on 22 Mary 2011 12 UTC')\nprint()\nprint(f'        CAPE: {cape:.2f}')\nprint(f'         CIN: {cin:.2f}')\nprint(f'LCL Pressure: {lclp:.2f}')\nprint(f'LFC Pressure: {lfcp:.2f}')\nprint(f' EL Pressure: {el_pressure:.2f}')\nprint()\nprint(f'   Lifted Index: {lift_index:.2f}')\nprint(f'        K-Index: {kindex:.2f}')\nprint(f'Showalter Index: {showalter:.2f}')\nprint(f'   Cross Totals: {ctotals:.2f}')\nprint(f'   Total Totals: {total_totals:.2f}')\nprint(f'Vertical Totals: {vert_totals:.2f}')\nprint()\nprint('Mixed Layer - Lowest 50-hPa')\nprint(f'     ML Temp: {ml_t:.2f}')\nprint(f'     ML Dewp: {ml_td:.2f}')\nprint(f'     ML CAPE: {mlcape:.2f}')\nprint(f'      ML CIN: {mlcin:.2f}')\nprint()\nprint('Most Unstable - Lowest 50-hPa')\nprint(f'     MU Temp: {mu_t:.2f}')\nprint(f'     MU Dewp: {mu_td:.2f}')\nprint(f' MU Pressure: {mu_p:.2f}')\nprint(f'     MU CAPE: {mucape:.2f}')\nprint(f'      MU CIN: {mucin:.2f}')\nprint()\nprint('Bunkers Storm Motion Vector')\nprint(f'  u_storm: {u_storm:.2f}')\nprint(f'  v_storm: {v_storm:.2f}')\nprint(f'Critical Angle: {critical_angle:.2f}')\nprint()\nprint(f'Storm Relative Helicity: {total_helicity:.2f}')\nprint(f'Significant Tornado Parameter: {sig_tor:.2f}')\nprint(f'Supercell Composite Parameter: {super_comp:.2f}')","type":"content","url":"/notebooks/skewt/sounding-calculations#assign-units","position":7},{"hierarchy":{"lvl1":"Sounding as Dataset Example"},"type":"lvl1","url":"/notebooks/skewt/sounding-lcl-dataset","position":0},{"hierarchy":{"lvl1":"Sounding as Dataset Example"},"content":"Use MetPy to make a Skew-T LogP plot from an xarray Dataset after computing LCL parcel profile.\n\n","type":"content","url":"/notebooks/skewt/sounding-lcl-dataset","position":1},{"hierarchy":{"lvl1":"Sounding as Dataset Example","lvl2":"Imports"},"type":"lvl2","url":"/notebooks/skewt/sounding-lcl-dataset#imports","position":2},{"hierarchy":{"lvl1":"Sounding as Dataset Example","lvl2":"Imports"},"content":"\n\nimport matplotlib.pyplot as plt\nimport numpy as np\nimport pandas as pd\n\nimport metpy.calc as mpcalc\nfrom metpy.cbook import get_test_data\nfrom metpy.plots import add_metpy_logo, SkewT\nfrom metpy.units import units\n\n","type":"content","url":"/notebooks/skewt/sounding-lcl-dataset#imports","position":3},{"hierarchy":{"lvl1":"Sounding as Dataset Example","lvl2":"Obtain Data and Format"},"type":"lvl2","url":"/notebooks/skewt/sounding-lcl-dataset#obtain-data-and-format","position":4},{"hierarchy":{"lvl1":"Sounding as Dataset Example","lvl2":"Obtain Data and Format"},"content":"\n\nUpper air data can be obtained using the siphon package, but for this example we will use some of MetPy’s sample data.\nas_file_obj=False), skiprows=5, usecols=[0, 1, 2, 3, 6, 7], names=col_names) is necessary due to the formatting of the MetPy sample data. This formatting is not needed when using upper air data obtained via Siphon. Obtaining data with Siphon will be covered in a later notebook.\n\ncol_names = ['pressure', 'height', 'temperature', 'dewpoint', 'direction', 'speed']\n\nsounding_data = pd.read_fwf(get_test_data('20110522_OUN_12Z.txt', as_file_obj=False),\n                 skiprows=7, usecols=[0, 1, 2, 3, 6, 7], names=col_names)\n\n# Drop any rows with all not a number (NaN) values for temperature, dewpoint, and winds\nsounding_data = sounding_data.dropna(subset=('temperature', 'dewpoint', 'direction', 'speed'),\n               how='all').reset_index(drop=True)\n\n","type":"content","url":"/notebooks/skewt/sounding-lcl-dataset#obtain-data-and-format","position":5},{"hierarchy":{"lvl1":"Sounding as Dataset Example","lvl2":"Assign Units"},"type":"lvl2","url":"/notebooks/skewt/sounding-lcl-dataset#assign-units","position":6},{"hierarchy":{"lvl1":"Sounding as Dataset Example","lvl2":"Assign Units"},"content":"\n\nWe will pull the data out of the example dataset into individual variables and assign units. This is explained in further detain in the Simple Sounding notebook and in the \n\nMetpy documentation.\n\npres = sounding_data['pressure'].values * units.hPa\ntemp = sounding_data['temperature'].values * units.degC\ndewpoint = sounding_data['dewpoint'].values * units.degC\nwind_speed = sounding_data['speed'].values * units.knots\nwind_dir = sounding_data['direction'].values * units.degrees\nu, v = mpcalc.wind_components(wind_speed, wind_dir)\n\nlcl_ds = mpcalc.parcel_profile_with_lcl_as_dataset(pres, temp, dewpoint)\n\nlcl_ds\n\n","type":"content","url":"/notebooks/skewt/sounding-lcl-dataset#assign-units","position":7},{"hierarchy":{"lvl1":"Sounding as Dataset Example","lvl2":"Create Sounding Plot"},"type":"lvl2","url":"/notebooks/skewt/sounding-lcl-dataset#create-sounding-plot","position":8},{"hierarchy":{"lvl1":"Sounding as Dataset Example","lvl2":"Create Sounding Plot"},"content":"\n\n# Create figure and set size\nfig = plt.figure(figsize=(9, 9))\nskew = SkewT(fig, rotation=45)\n\n# Plot the data using the data from the xarray Dataset including the parcel temperature with\n# the LCL level included\nskew.plot(lcl_ds.isobaric, lcl_ds.ambient_temperature, 'red')\nskew.plot(lcl_ds.isobaric, lcl_ds.ambient_dew_point, 'green')\nskew.plot(lcl_ds.isobaric, lcl_ds.parcel_temperature.metpy.convert_units('degC'), 'black')\n\n# Plot wind barbs\nmy_interval = np.arange(100, 1000, 50) * units('hPa') #set spacing interval\nix = mpcalc.resample_nn_1d(pres, my_interval) #find nearest indices for chosen interval\nskew.plot_barbs(pres[ix], u[ix], v[ix], xloc=1) #plot values closest to chosen interval\n\n# Improve labels and set axis limits\nskew.ax.set_xlabel('Temperature (\\N{DEGREE CELSIUS})')\nskew.ax.set_ylabel('Pressure (hPa)')\nskew.ax.set_ylim(1000, 100)\nskew.ax.set_xlim(-40, 59)\n\n# Add the relevant special lines throughout the figure\nskew.plot_dry_adiabats(t0=np.arange(233, 533, 15) * units.K, alpha=0.25, color='orangered')\nskew.plot_moist_adiabats(t0=np.arange(233, 400, 10) * units.K, alpha=0.25, color='tab:green')\nskew.plot_mixing_lines(pressure=np.arange(1000, 99, -25) * units.hPa, linestyle='dotted', color='tab:blue')\n\n# Add the MetPy logo!\nfig = plt.gcf()\nadd_metpy_logo(fig, 115, 100, size='small');\n\n# Add titles\nplt.title('KOUN', loc='left')\nplt.title('2011-05-22 12 UTC', loc='right');","type":"content","url":"/notebooks/skewt/sounding-lcl-dataset#create-sounding-plot","position":9},{"hierarchy":{"lvl1":"Sounding Plotter"},"type":"lvl1","url":"/notebooks/skewt/sounding-plotter","position":0},{"hierarchy":{"lvl1":"Sounding Plotter"},"content":"This can be run as a script from the command line or as a notebook.\n\nDownload and plot the most recent sounding data for a specified site.\n\nProvides a simple command line interface to specify a site. Using the current\nUTC time, the script calculates what the most recent sounding should be and requests\nit from the Wyoming archive using Siphon.\n\n","type":"content","url":"/notebooks/skewt/sounding-plotter","position":1},{"hierarchy":{"lvl1":"Sounding Plotter","lvl2":"Imports"},"type":"lvl2","url":"/notebooks/skewt/sounding-plotter#imports","position":2},{"hierarchy":{"lvl1":"Sounding Plotter","lvl2":"Imports"},"content":"\n\nimport posixpath\n\nimport numpy as np\nimport matplotlib.pyplot as plt\nimport metpy.calc as mpcalc\nfrom metpy.plots import add_metpy_logo, add_timestamp, SkewT\nfrom metpy.units import units\n\nfrom siphon.simplewebservice.wyoming import WyomingUpperAir\n\n\nThis class encapsulates the code needed to upload an image to Google Drive\n\nclass DriveUploader:\n    def __init__(self, credsfile='mycreds.txt'):\n        from pydrive.drive import GoogleDrive\n        self.gdrive = GoogleDrive(self._get_auth(credsfile))\n\n    def _get_auth(self, credsfile):\n        from pydrive.auth import GoogleAuth\n        gauth = GoogleAuth()\n\n        # Try to load saved client credentials\n        gauth.LoadCredentialsFile(credsfile)\n        if gauth.credentials is None:\n            # Authenticate if they're not there\n            gauth.LocalWebserverAuth()\n        elif gauth.access_token_expired:\n            # Refresh them if expired\n            gauth.Refresh()\n        else:\n            # Initialize the saved creds\n            gauth.Authorize()\n        # Save the current credentials to a file\n        gauth.SaveCredentialsFile(credsfile)\n        return gauth\n\n    def _get_first_file_id(self, title, parent, **kwargs):\n        query = \"title='{}' and '{}' in parents\".format(title, parent)\n        for k, v in kwargs.items():\n            query += \" and {}='{}'\".format(k, v)\n        res = next(self.gdrive.ListFile({'q': query}))\n        if res:\n            return res[0]['id']\n        return None\n\n    def get_folder(self, path):\n        parent = 'root'\n        for part in path.split('/'):\n            if not part:\n                continue\n            parent = self._get_first_file_id(part, parent,\n                                             mimeType='application/vnd.google-apps.folder')\n        return parent\n\n    def create_or_get_file(self, path):\n        pathname, filename = posixpath.split(path)\n        folder = self.get_folder(pathname)\n        create_file_args = {'parents': [{'kind': 'drive#fileLink', 'id': folder}]}\n\n        file_id = self._get_first_file_id(filename, folder)\n        if file_id is not None:\n            create_file_args['id'] = file_id\n        return self.gdrive.CreateFile(create_file_args)\n\n    def upload_to(self, local_path, remote_path):\n        f = self.create_or_get_file(remote_path)\n        f.SetContentFile(local_path)\n        f['title'] = posixpath.basename(remote_path)\n        f.Upload()\n\nThis function takes care of actually generating a skewT from the DataFrame\n\ndef plot_skewt(df):\n    # We will pull the data out of the example dataset into individual variables\n    # and assign units.\n    pres = df['pressure'].values * units.hPa\n    temp = df['temperature'].values * units.degC\n    dewpoint = df['dewpoint'].values * units.degC\n    wind_speed = df['speed'].values * units.knots\n    wind_dir = df['direction'].values * units.degrees\n    u, v = mpcalc.wind_components(wind_speed, wind_dir)\n\n    # Create a new figure. The dimensions here give a good aspect ratio.\n    fig = plt.figure(figsize=(9, 9))\n    skew = SkewT(fig, rotation=45)\n\n    # Plot temperature, dewpoint and wind barbs\n    skew.plot(pres, temp, 'red')\n    skew.plot(pres, dewpoint, 'green')\n    \n    # Plot wind barbs\n    my_interval = np.arange(100, 1000, 50) * units('hPa') #set spacing interval\n    ix = mpcalc.resample_nn_1d(pres, my_interval) #find nearest indices for chosen interval\n    skew.plot_barbs(pres[ix], u[ix], v[ix], xloc=1) #plot values closest to chosen interval\n    \n    # Improve labels and set axis limits\n    skew.ax.set_xlabel('Temperature (\\N{DEGREE CELSIUS})')\n    skew.ax.set_ylabel('Pressure (hPa)')\n    skew.ax.set_ylim(1000, 100)\n    skew.ax.set_xlim(-40, 59)\n\n    # Calculate LCL height and plot as black dot.\n    lcl_pressure, lcl_temperature = mpcalc.lcl(pres[0], temp[0], dewpoint[0]) #index 0 is chosen to lift parcel from the surface\n    skew.plot(lcl_pressure, lcl_temperature, 'ko', markerfacecolor='black')\n\n    # Calculate full parcel profile and add to plot as black line\n    prof = mpcalc.parcel_profile(pres, temp[0], dewpoint[0]).to('degC')\n    skew.plot(pres, prof, 'black', linewidth=2)\n\n    # Shade areas of CAPE and CIN\n    skew.shade_cin(pres, temp, prof, dewpoint)\n    skew.shade_cape(pres, temp, prof)\n\n    # Add emphasis to 0 degree isotherm with color change\n    skew.ax.axvline(0, color='c', linestyle='--', linewidth=2)\n\n    # Add the relevant special lines throughout the figure\n    skew.plot_dry_adiabats(t0=np.arange(233, 533, 15) * units.K, alpha=0.25, color='orangered')\n    skew.plot_moist_adiabats(t0=np.arange(233, 400, 10) * units.K, alpha=0.25, color='tab:green')\n    skew.plot_mixing_lines(pressure=np.arange(1000, 99, -25) * units.hPa, linestyle='dotted', color='tab:blue')\n\n    # Add the MetPy logo!\n    fig = plt.gcf()\n    add_metpy_logo(fig, 115, 100, size='small');\n    \n    return skew\n\n\ndef make_name(site, time):\n    return '{site}_{dt:%Y%m%d_%H%M}.png'.format(site=site, dt=time)\n\nThis is where the command line script will actually enter, and handles parsing\ncommand line arguments and driving everything else.\n\nif __name__ == '__main__':\n    import argparse\n    from datetime import datetime, timedelta, UTC\n    import tempfile\n\n    # Set up argument parsing for the script. Provides one argument for the site, and another\n    # that controls whether the plot should be shown or saved as an image.\n    parser = argparse.ArgumentParser(description='Download sounding data and plot.')\n    parser.add_argument('-s', '--site', help='Site to obtain data for', type=str,\n                        default='DDC')\n    parser.add_argument('--show', help='Whether to show the plot rather than save to disk',\n                        action='store_true')\n    parser.add_argument('-d', '--date', help='Date and time to request data for in YYYYMMDDHH.'\n                        ' Defaults to most recent 00/12 hour.', type=str)\n    parser.add_argument('-g', '--gdrive', help='Google Drive upload path', type=str)\n    parser.add_argument('-f', '--filename', help='Image filename', type=str)\n    args = parser.parse_args()\n\n    if args.date:\n        request_time = datetime.strptime(args.date, '%Y%m%d%H')\n    else:\n        # Figure out the most recent sounding, 00 or 12. Subtracting two hours\n        # helps ensure that we choose a time with data available.\n        now = datetime.now(UTC) - timedelta(hours=2)\n        request_time = now.replace(hour=(now.hour // 12) * 12, minute=0, second=0)\n\n    # Request the data and plot\n    df = WyomingUpperAir.request_data(request_time, args.site)\n    skewt = plot_skewt(df)\n\n    # Add the timestamp for the data to the plot\n    add_timestamp(skewt.ax, request_time, y=1.02, x=0, ha='left', fontsize='large')\n    skewt.ax.set_title(args.site)\n\n    if args.show:\n        plt.show()\n    else:\n        fname = args.filename if args.filename else make_name(args.site, request_time)\n        if args.gdrive:\n            uploader = DriveUploader()\n            with tempfile.NamedTemporaryFile(suffix='.png') as f:\n                skewt.ax.figure.savefig(f.name)\n                uploader.upload_to(f.name, posixpath.join(args.gdrive, fname))\n        else:\n            skewt.ax.figure.savefig(make_name(args.site, request_time))","type":"content","url":"/notebooks/skewt/sounding-plotter#imports","position":3},{"hierarchy":{"lvl1":"Skew-T Analysis"},"type":"lvl1","url":"/notebooks/skewt","position":0},{"hierarchy":{"lvl1":"Skew-T Analysis"},"content":"The Skew-T Log-P diagram, or “Skew-T” for short, is a type of plot specific\nto meteorology that is frequently used in the analysis of vertical profiles of\ntemperature and humidity. For instance, the data collected by weather balloons\nin 12-hourly soundings are often shown with such plots, as they foster an\nunderstanding of e.g. the stability of the atmosphere above a location.\n\nThe units in this chapter show ways to use MetPy to generate skew-T plots and\ncustomize them with various pieces of information.","type":"content","url":"/notebooks/skewt","position":1},{"hierarchy":{"lvl1":"Hovmoller Diagram Example"},"type":"lvl1","url":"/notebooks/specialty/hovmoller-diagram","position":0},{"hierarchy":{"lvl1":"Hovmoller Diagram Example"},"content":"By: Kevin Goebbert\n\nNorthern Hemispheric v-wind component over the mid-latitudes in a\nHovmoller diagram. This diagram can be used to illustrate upper-level\nwave and energy propogation (e.g., downstream baroclinic development)\n\nimport cartopy.crs as ccrs\nimport cartopy.feature as cfeature\nimport matplotlib.gridspec as gridspec\nimport matplotlib.pyplot as plt\nimport metpy.calc as mpcalc\nimport numpy as np\nimport xarray as xr\n\n","type":"content","url":"/notebooks/specialty/hovmoller-diagram","position":1},{"hierarchy":{"lvl1":"Hovmoller Diagram Example","lvl2":"Get the data"},"type":"lvl2","url":"/notebooks/specialty/hovmoller-diagram#get-the-data","position":2},{"hierarchy":{"lvl1":"Hovmoller Diagram Example","lvl2":"Get the data"},"content":"Using NCEP/NCAR reanalysis data via xarray remote access using the\nOPeNDAP protocol.\n\nSet the time range, parameter, and level to desired values\n\n# Create time slice from dates\nstart_time = '2011-01-20'\nend_time = '2011-02-06'\n\n# Select NCEP/NCAR parameter and level\nparam = 'vwnd'\nlevel = 250\n\n# Remote get dataset using OPeNDAP method via xarray\nds = xr.open_dataset('http://www.esrl.noaa.gov/psd/thredds/dodsC/Datasets/'\n                     f'ncep.reanalysis/pressure/{param}.{start_time[:4]}.nc')\n\n# Create slice variables subset domain\ntime_slice = slice(start_time, end_time)\nlat_slice = slice(60, 40)\nlon_slice = slice(0, 360)\n\n# Get data, selecting time, level, lat/lon slice\ndata = ds[param].sel(time=time_slice,\n                     level=level,\n                     lat=lat_slice,\n                     lon=lon_slice)\n\n# Compute weights and take weighted average over latitude dimension\nweights = np.cos(np.deg2rad(data.lat.values))\navg_data = (data * weights[None, :, None]).sum(dim='lat') / np.sum(weights)\n\n# Get times and make array of datetime objects\nvtimes = data.time.values.astype('datetime64[ms]').astype('O')\n\n# Specify longitude values for chosen domain\nlons = data.lon.values\n\n","type":"content","url":"/notebooks/specialty/hovmoller-diagram#get-the-data","position":3},{"hierarchy":{"lvl1":"Hovmoller Diagram Example","lvl2":"Make the Hovmoller Plot"},"type":"lvl2","url":"/notebooks/specialty/hovmoller-diagram#make-the-hovmoller-plot","position":4},{"hierarchy":{"lvl1":"Hovmoller Diagram Example","lvl2":"Make the Hovmoller Plot"},"content":"Pretty simple to use common matplotlib/cartopy to create the diagram.\nCartopy is used to create a geographic reference map to highlight the\narea being averaged as well as the visual reference for longitude.\n\n# Start figure\nfig = plt.figure(figsize=(10, 13))\n\n# Use gridspec to help size elements of plot; small top plot\n# and big bottom plot\ngs = gridspec.GridSpec(nrows=2, ncols=1, height_ratios=[1, 6], hspace=0.03)\n\n# Tick labels\nx_tick_labels = [u'0\\N{DEGREE SIGN}E', u'90\\N{DEGREE SIGN}E',\n                 u'180\\N{DEGREE SIGN}E', u'90\\N{DEGREE SIGN}W',\n                 u'0\\N{DEGREE SIGN}E']\n\n# Top plot for geographic reference (makes small map)\nax1 = fig.add_subplot(gs[0, 0],\n                      projection=ccrs.PlateCarree(central_longitude=180))\nax1.set_extent([0, 357.5, 35, 65], ccrs.PlateCarree(central_longitude=180))\nax1.set_yticks([40, 60])\nax1.set_yticklabels([u'40\\N{DEGREE SIGN}N', u'60\\N{DEGREE SIGN}N'])\nax1.set_xticks([-180, -90, 0, 90, 180])\nax1.set_xticklabels(x_tick_labels)\nax1.grid(linestyle='dotted', linewidth=2)\n\n# Add geopolitical boundaries for map reference\nax1.add_feature(cfeature.COASTLINE.with_scale('50m'))\nax1.add_feature(cfeature.LAKES.with_scale('50m'), color='black',\n                linewidths=0.5)\n\n# Set some titles\nplt.title('Hovmoller Diagram', loc='left')\nplt.title('NCEP/NCAR Reanalysis', loc='right')\n\n# Bottom plot for Hovmoller diagram\nax2 = fig.add_subplot(gs[1, 0])\nax2.invert_yaxis()  # Reverse the time order to do oldest first\n\n# Plot of chosen variable averaged over latitude and slightly smoothed\nclevs = np.arange(-50, 51, 5)\ncf = ax2.contourf(lons, vtimes, mpcalc.smooth_n_point(\n    avg_data, 9, 2), clevs, cmap=plt.cm.bwr, extend='both')\ncs = ax2.contour(lons, vtimes, mpcalc.smooth_n_point(\n    avg_data, 9, 2), clevs, colors='k', linewidths=1)\ncbar = plt.colorbar(cf, orientation='horizontal', pad=0.04, aspect=50,\n                    extendrect=True)\ncbar.set_label('m $s^{-1}$')\n\n# Make some ticks and tick labels\nax2.set_xticks([0, 90, 180, 270, 357.5])\nax2.set_xticklabels(x_tick_labels)\nax2.set_yticks(vtimes[4::8])\nax2.set_yticklabels(vtimes[4::8])\n\n# Set some titles\nplt.title('250-hPa V-wind', loc='left', fontsize=10)\nplt.title(f'Time Range: {vtimes[0]:%Y%m%d %HZ} - {vtimes[-1]:%Y%m%d %HZ}',\n          loc='right', fontsize=10)","type":"content","url":"/notebooks/specialty/hovmoller-diagram#make-the-hovmoller-plot","position":5},{"hierarchy":{"lvl1":"Real Data Cross-Section Example"},"type":"lvl1","url":"/notebooks/specialty/observational-data-cross-section","position":0},{"hierarchy":{"lvl1":"Real Data Cross-Section Example"},"content":"Cross-section using real data from soundings.\n\nThis example uses actual soundings to create a cross-section. There are\ntwo functions defined to help interpolate radiosonde observations, which\nwon’t all be at the same level, to a standard grid. The vertical\ninterpolation assumes a log-linear relationship. Each radisosonde\nvertical profile is interpolated first, then the\nscipy.interpolate.griddata function is used to generate a full 2D\n(x, p) grid between each station. Pyproj is used to calculate the\ndistance between each station and the standard atmosphere is used to\nconvert the elevation of each station to a pressure value for plotting\npurposes.\n\nfrom datetime import datetime\n\nimport matplotlib.pyplot as plt\nimport metpy.calc as mpcalc\nfrom metpy.units import units\nimport numpy as np\nfrom siphon.simplewebservice.wyoming import WyomingUpperAir\n\n","type":"content","url":"/notebooks/specialty/observational-data-cross-section","position":1},{"hierarchy":{"lvl1":"Real Data Cross-Section Example","lvl2":"Vertical Interpolation Function"},"type":"lvl2","url":"/notebooks/specialty/observational-data-cross-section#vertical-interpolation-function","position":2},{"hierarchy":{"lvl1":"Real Data Cross-Section Example","lvl2":"Vertical Interpolation Function"},"content":"Function interpolates to given pressure level data to set grid.\n\ndef vertical_interpolate(vcoord_data, interp_var, interp_levels):\n    \"\"\"A function to interpolate sounding data from each station to\n    every millibar. Assumes a log-linear relationship.\n\n    Input\n    -----\n    vcoord_data : A 1D array of vertical level values (e.g., pressure from a radiosonde)\n    interp_var : A 1D array of the variable to be interpolated to all pressure levels\n    vcoord_interp_levels : A 1D array containing veritcal levels to interpolate to\n\n    Return\n    ------\n    interp_data : A 1D array that contains the interpolated variable on the interp_levels\n    \"\"\"\n    # Make veritcal coordinate data and grid level log variables\n    lnp = np.log(vcoord_data)\n    lnp_intervals = np.log(interp_levels)\n\n    # Use numpy to interpolate from observed levels to grid levels\n    interp_data = np.interp(lnp_intervals[::-1], lnp[::-1], interp_var[::-1])[::-1]\n\n    # Mask for missing data (generally only near the surface)\n    mask_low = interp_levels > vcoord_data[0]\n    mask_high = interp_levels < vcoord_data[-1]\n    interp_data[mask_low] = interp_var[0]\n    interp_data[mask_high] = interp_var[-1]\n\n    return interp_data\n\n","type":"content","url":"/notebooks/specialty/observational-data-cross-section#vertical-interpolation-function","position":3},{"hierarchy":{"lvl1":"Real Data Cross-Section Example","lvl2":"Radiosonde Observation Interpolation Function"},"type":"lvl2","url":"/notebooks/specialty/observational-data-cross-section#radiosonde-observation-interpolation-function","position":4},{"hierarchy":{"lvl1":"Real Data Cross-Section Example","lvl2":"Radiosonde Observation Interpolation Function"},"content":"This function interpolates given radiosonde data into a 2D array for all\nmeteorological variables given in dataframe. Returns a dictionary that\nwill have requesite data for plotting a cross section.\n\ndef radiosonde_cross_section(stns, data, start=1000, end=100, step=10):\n    \"\"\"This function takes a list of radiosonde observation sites with a\n    dictionary of Pandas Dataframes with the requesite data for each station.\n\n    Input\n    -----\n    stns : List of statition three-letter identifiers\n    data : A dictionary of Pandas Dataframes containing the radiosonde observations\n    for the stations\n    start : interpolation start value, optional (default = 1000 hPa)\n    end : Interpolation end value, optional (default = 100 hPa)\n    step : Interpolation interval, option (default = 10 hPa)\n\n    Return\n    ------\n    cross_section : A dictionary that contains the following variables\n\n        grid_data : An interpolated grid with 100 points between the first and last station,\n        with the corresponding number of vertical points based on start, end, and interval\n        (default is 90)\n        obs_distance : An array of distances between each radiosonde observation location\n        x_grid : A 2D array of horizontal direction grid points\n        p_grid : A 2D array of vertical pressure levels\n        ground_elevation : A representation of the terrain between radiosonde observation sites\n        based on the elevation of each station converted to pressure using the standard\n        atmosphere\n\n    \"\"\"\n    from pyproj import Geod\n    from scipy.interpolate import griddata\n    \n    data_units = {'pressure': 'hPa',\n                  'height': 'meter',\n                  'temperature': 'degC',\n                  'dewpoint': 'degC',\n                  'direction': 'degrees',\n                  'speed': 'knot',\n                  'u_wind': 'knot',\n                  'v_wind': 'knot',\n                  'station': None,\n                  'station_number': None,\n                  'time': None,\n                  'latitude': 'degrees',\n                  'longitude': 'degrees',\n                  'elevation': 'meter',\n                  'pw': 'millimeter'}\n    # Set up vertical grid, largest value first (high pressure nearest surface)\n    vertical_levels = np.arange(start, end-1, -step) * units(data_units['pressure'])\n\n    # Number of vertical levels and stations\n    plevs = len(vertical_levels)\n    nstns = len(stns)\n\n    # Create dictionary of interpolated values and include neccsary attribute data\n    # including lat, lon, and elevation of each station\n    lats = []\n    lons = []\n    elev = []\n    keys = data[stns[0]].keys()[:8]\n    tmp_grid = dict.fromkeys(keys)\n\n    # Interpolate all variables for each radiosonde observation\n    # Temperature, Dewpoint, U-wind, V-wind\n    for key in tmp_grid.keys():\n        tmp_grid[key] = np.empty((nstns, plevs))\n        for station, loc in zip(stns, range(nstns)):\n            if key == 'pressure':\n                lats.append(data[station].latitude[0])\n                lons.append(data[station].longitude[0])\n                elev.append(data[station].elevation[0])\n                tmp_grid[key][loc, :] = vertical_levels\n            else:\n                tmp_grid[key][loc, :] = vertical_interpolate(\n                    data[station]['pressure'].values, data[station][key].values,\n                    vertical_levels.m)\n\n    # Compute distance between each station using Pyproj\n    g = Geod(ellps='sphere')\n    _, _, dist = g.inv(nstns*[lons[0]], nstns*[lats[0]], lons[:], lats[:])\n\n    # Compute sudo ground elevation in pressure from standard atmsophere and the elevation\n    # of each station\n    ground_elevation = mpcalc.height_to_pressure_std(np.array(elev) * units('meters'))\n\n    # Set up grid for 2D interpolation\n    grid = dict.fromkeys(keys)\n    x = np.linspace(dist[0], dist[-1], 100)\n    nx = len(x)\n\n    pp, xx = np.meshgrid(vertical_levels.m, x)\n    pdist, ddist = np.meshgrid(vertical_levels.m, dist)\n\n    # Interpolate to 2D grid using scipy.interpolate.griddata\n    for key in grid.keys():\n        grid[key] = np.empty((nx, plevs)) * units(data_units[key])\n        grid[key][:] = griddata((ddist.flatten(), pdist.flatten()),\n                                tmp_grid[key][:].flatten(),\n                                (xx, pp),\n                                method='cubic') * units(data_units[key])\n\n    # Gather needed data in dictionary for return\n    cross_section = {'grid_data': grid, 'obs_distance': dist * units.meter,\n                     'x_grid': xx * units.meter, 'p_grid': pp * units.hPa, 'elevation': ground_elevation}\n    return cross_section\n\n","type":"content","url":"/notebooks/specialty/observational-data-cross-section#radiosonde-observation-interpolation-function","position":5},{"hierarchy":{"lvl1":"Real Data Cross-Section Example","lvl2":"Stations and Time"},"type":"lvl2","url":"/notebooks/specialty/observational-data-cross-section#stations-and-time","position":6},{"hierarchy":{"lvl1":"Real Data Cross-Section Example","lvl2":"Stations and Time"},"content":"Select cross section stations by creating a list of three-letter\nidentifiers and choose a date by creating a datetime object\n\n# A roughly east-west cross section\nstn_list = ['DNR', 'LBF', 'OAX', 'DVN', 'DTX', 'BUF']\n\n# Set a date and hour of your choosing\ndate = datetime(2019, 6, 1, 0)\n\n","type":"content","url":"/notebooks/specialty/observational-data-cross-section#stations-and-time","position":7},{"hierarchy":{"lvl1":"Real Data Cross-Section Example","lvl2":"Get Radiosonde Data"},"type":"lvl2","url":"/notebooks/specialty/observational-data-cross-section#get-radiosonde-data","position":8},{"hierarchy":{"lvl1":"Real Data Cross-Section Example","lvl2":"Get Radiosonde Data"},"content":"This example is built around the data from the University of Wyoming\nsounding archive and using the Siphon package to remotely access that\ndata.\n\n# Set up empty dictionary to fill with Wyoming Sounding data\ndf = {}\n\n# Loop over stations to get data and put into dictionary\nfor station in stn_list:\n    df[station] = WyomingUpperAir.request_data(date, station)\n\n","type":"content","url":"/notebooks/specialty/observational-data-cross-section#get-radiosonde-data","position":9},{"hierarchy":{"lvl1":"Real Data Cross-Section Example","lvl2":"Create Interpolated fields"},"type":"lvl2","url":"/notebooks/specialty/observational-data-cross-section#create-interpolated-fields","position":10},{"hierarchy":{"lvl1":"Real Data Cross-Section Example","lvl2":"Create Interpolated fields"},"content":"Use the function radisonde_cross_section to generate the 2D grid (x,\np) for all radiosonde variables including, Temperature, Dewpoint,\nu-component of the wind, and v-component of the wind.\n\nxsect = radiosonde_cross_section(stn_list, df)\n\n","type":"content","url":"/notebooks/specialty/observational-data-cross-section#create-interpolated-fields","position":11},{"hierarchy":{"lvl1":"Real Data Cross-Section Example","lvl2":"Calculate Variables for Plotting"},"type":"lvl2","url":"/notebooks/specialty/observational-data-cross-section#calculate-variables-for-plotting","position":12},{"hierarchy":{"lvl1":"Real Data Cross-Section Example","lvl2":"Calculate Variables for Plotting"},"content":"Use MetPy to calculate common variables for plotting a cross section,\nspecifically potential temperature and mixing ratio\n\npotemp = mpcalc.potential_temperature(\n    xsect['p_grid'], xsect['grid_data']['temperature'])\n\nrelhum = mpcalc.relative_humidity_from_dewpoint(\n    xsect['grid_data']['temperature'],\n    xsect['grid_data']['dewpoint'])\n\nmixrat = mpcalc.mixing_ratio_from_relative_humidity(xsect['p_grid'],\n                                                    xsect['grid_data']['temperature'],\n                                                    relhum)\n\n","type":"content","url":"/notebooks/specialty/observational-data-cross-section#calculate-variables-for-plotting","position":13},{"hierarchy":{"lvl1":"Real Data Cross-Section Example","lvl2":"Plot Cross Section"},"type":"lvl2","url":"/notebooks/specialty/observational-data-cross-section#plot-cross-section","position":14},{"hierarchy":{"lvl1":"Real Data Cross-Section Example","lvl2":"Plot Cross Section"},"content":"Use standard Matplotlib to plot the now 2D cross section grid using the\ndata from xsect and those calculated above. Additionally, the actualy\nradiosonde wind observations are plotted as barbs on this plot.\n\n# Start Figure, set big size for cross section\nfig = plt.figure(figsize=(17, 11))\n\n# Specify plotting axis (single panel)\nax = plt.subplot(111)\n\n# Set y-scale to be log since pressure decreases exponentially with height\nax.set_yscale('log')\n\n# Set limits, tickmarks, and ticklabels for y-axis\nax.set_ylim([1030, 101])\nax.set_yticks(range(1000, 101, -100))\nax.set_yticklabels(range(1000, 101, -100))\n\n# Invert the y-axis since pressure decreases with increasing height\nax.yaxis_inverted()\n\n# Plot the sudo elevation on the cross section\nax.fill_between(xsect['obs_distance'], xsect['elevation'].m, 1030,\n                where=xsect['elevation'].m <= 1030, facecolor='lightgrey',\n                interpolate=True, zorder=10)\n# Don't plot xticks\nplt.xticks([], [])\n\n# Plot wind barbs for each sounding location\nfor stn, stn_name in zip(range(len(stn_list)), stn_list):\n    ax.axvline(xsect['obs_distance'][stn], ymin=0, ymax=1,\n               linewidth=2, color='blue', zorder=11)\n    ax.text(xsect['obs_distance'][stn], 1100, stn_name, ha='center', color='blue')\n    ax.barbs(xsect['obs_distance'][stn], df[stn_name]['pressure'][::2],\n             df[stn_name]['u_wind'].values[::2, None],\n             df[stn_name]['v_wind'].values[::2, None], zorder=15)\n\n# Plot smoothed potential temperature grid (K)\ncs = ax.contour(xsect['x_grid'], xsect['p_grid'], mpcalc.smooth_gaussian(potemp, 1),\n                range(0, 500, 5), colors='red')\nax.clabel(cs, fmt='%i')\n\n# Plot smoothed mixing ratio grid (g/kg)\ncs = ax.contour(xsect['x_grid'], xsect['p_grid'], mpcalc.smooth_gaussian(mixrat*1000, 2),\n                range(0, 41, 2), colors='tab:green', linestyles='dotted')\nax.clabel(cs, fmt='%i')\n\n# Add some informative titles\nplt.title('Cross-Section from DNR to BUF Potential Temp. '\n          '(K; red) and Mix. Rat. (g/kg; green)', loc='left')\nplt.title(date, loc='right');","type":"content","url":"/notebooks/specialty/observational-data-cross-section#plot-cross-section","position":15},{"hierarchy":{"lvl1":"Smoothing Contours"},"type":"lvl1","url":"/notebooks/specialty/smoothing-contours","position":0},{"hierarchy":{"lvl1":"Smoothing Contours"},"content":"Demonstrate how to smooth contour values from a higher resolution\nmodel field.\n\nBy: Kevin Goebbert\n\nDate: 13 April 2017\n\nDo the needed imports\n\nfrom datetime import datetime, UTC\n\nimport cartopy.crs as ccrs\nimport cartopy.feature as cfeature\nimport matplotlib.pyplot as plt\nimport metpy.calc as mpcalc\nimport numpy as np\nfrom metpy.units import units\nfrom siphon.catalog import TDSCatalog\nfrom xarray.backends import NetCDF4DataStore\nimport xarray as xr\n\nSet up netCDF Subset Service link\n\n# Specify our date/time of product desired\ndt = datetime.now(UTC)\n\n# Construct the URL for our THREDDS Data Server Catalog,\n# and access our desired dataset within via NCSS\ncat = TDSCatalog('https://thredds.ucar.edu/thredds/catalog/grib/'\n                 'NCEP/NAM/CONUS_12km/latest.xml')\nncss = cat.datasets[0].subset()\n\n# Create our NCSS query with desired specifications\nquery = ncss.query()\nquery.time(dt)\nquery.add_lonlat()\nquery.variables('Geopotential_height_isobaric',\n                'u-component_of_wind_isobaric',\n                'v-component_of_wind_isobaric')\n\n# Obtain the data we've queried for\ndata = ncss.get_data(query)\n\n# Make into an xarray Dataset object\nds = xr.open_dataset(NetCDF4DataStore(data)).metpy.parse_cf()\n\nPull apart the data\n\n# Get dimension names to pull appropriate variables\n# dtime = ds.Geopotential_height_isobaric.dims[0]\n# dlev = ds.Geopotential_height_isobaric.dims[1]\n# dlat = ds.Geopotential_height_isobaric.dims[2]\n# dlon = ds.Geopotential_height_isobaric.dims[3]\n\n# Get lat and lon data, as well as time data and metadata\nlats = ds.lat\nlons = ds.lon\n\n# Need 2D lat/lons for plotting, do so if necessary\nif lats.ndim < 2:\n    lons, lats = np.meshgrid(lons, lats)\n\n# Determine the level of 500 hPa\nlev_500 = 500 * units.hPa\n\n# Create more useable times for output\ntimes = ds.Geopotential_height_isobaric.metpy.time.squeeze()\nvtimes = times.values.astype('datetime64[ms]').astype('O')\n\n# Pull out the 500 hPa Heights\nhght_500 = ds.Geopotential_height_isobaric.metpy.sel(\n    vertical=lev_500).squeeze()\nuwnd_500 = ds['u-component_of_wind_isobaric'].metpy.sel(\n    vertical=lev_500).squeeze()\nvwnd_500 = ds['v-component_of_wind_isobaric'].metpy.sel(\n    vertical=lev_500).squeeze()\n\n# Calculate the magnitude of the wind speed in kts\nsped = mpcalc.wind_speed(uwnd_500, vwnd_500).metpy.convert_units('knots')\n\nSet up the projection for LCC\n\nplotcrs = ccrs.LambertConformal(central_longitude=-100.0,\n                                central_latitude=45.0)\ndatacrs = ccrs.PlateCarree(central_longitude=0.)\n\nSubset and smooth\n\n# Smooth the 500-hPa geopotential height field\n# Be sure to only smooth the 2D field\nZ_500 = mpcalc.smooth_gaussian(hght_500, 50)\n\nPlot the contours\n\n# Start plot with new figure and axis\nfig = plt.figure(figsize=(17., 11.))\nax = plt.subplot(1, 1, 1, projection=plotcrs)\n\n# Add some titles to make the plot readable by someone else\nplt.title('500-hPa Geo Heights (m; black), Smoothed 500-hPa Geo. '\n          'Heights (m; red)', loc='left')\nplt.title(f'VALID: {vtimes}', loc='right')\n\n# Set GAREA and add map features\nax.set_extent([-125., -67., 22., 52.], ccrs.PlateCarree())\nax.coastlines('50m', edgecolor='black', linewidth=0.75)\nax.add_feature(cfeature.STATES, linewidth=0.5)\n\n# Set the CINT\nclev500 = np.arange(5100, 6000, 60)\n\n# Plot smoothed 500-hPa contours\ncs2 = ax.contour(lons, lats, Z_500, clev500, colors='black',\n                 linewidths=3, linestyles='solid', transform=datacrs)\nc2 = plt.clabel(cs2, fontsize=12, colors='black', inline=1, inline_spacing=8,\n                fmt='%i', rightside_up=True, use_clabeltext=True)\n\n# Contour the 500 hPa heights with labels\ncs = ax.contour(lons, lats, hght_500, clev500, colors='red',\n                linewidths=2.5, linestyles='solid', alpha=0.6,\n                transform=datacrs)\ncl = plt.clabel(cs, fontsize=12, colors='red', inline=1, inline_spacing=8,\n                fmt='%i', rightside_up=True, use_clabeltext=True)","type":"content","url":"/notebooks/specialty/smoothing-contours","position":1},{"hierarchy":{"lvl1":"Specialty Plotting"},"type":"lvl1","url":"/notebooks/specialty","position":0},{"hierarchy":{"lvl1":"Specialty Plotting"},"content":"This section shows how to accomplish some specialty plotting, such as cross-sections and smoothing, using MetPy.","type":"content","url":"/notebooks/specialty","position":1},{"hierarchy":{"lvl1":"A 250-hPa Hemispheric Map using Python"},"type":"lvl1","url":"/notebooks/synoptic/hpa-hemispheric-plot","position":0},{"hierarchy":{"lvl1":"A 250-hPa Hemispheric Map using Python"},"content":"This example plots a hemispheric plot of GFS 250-hPa Geopotential Heights and\nwind speed in knots.\n\nfrom datetime import datetime, UTC\n\nimport cartopy.crs as ccrs\nimport cartopy.feature as cfeature\nimport cartopy.util as cutil\nimport matplotlib.pyplot as plt\nimport metpy.calc as mpcalc\nimport numpy as np\nfrom siphon.catalog import TDSCatalog\nfrom siphon.ncss import NCSS\nfrom xarray.backends import NetCDF4DataStore\nimport xarray as xr\n\n# Latest GFS Dataset\ncat = TDSCatalog('http://thredds.ucar.edu/thredds/catalog/grib/'\n                 'NCEP/GFS/Global_0p5deg/latest.xml')\nbest_ds = list(cat.datasets.values())[0]\nncss = NCSS(best_ds.access_urls['NetcdfSubset'])\n\n# Set the time to current\nnow = datetime.now(UTC)\n\n# Query for Latest GFS Run\ngfsdata_hght = ncss.query().time(now).accept('netcdf4')\ngfsdata_hght.variables('Geopotential_height_isobaric')\n\n# Set the lat/lon box for the data you want to pull in.\n# lonlat_box(north_lat,south_lat,east_lon,west_lon)\ngfsdata_hght.lonlat_box(0, 359.9, 0, 90)\n\n# Set desired level 50000 = 50000 Pa = 500 hPa\ngfsdata_hght.vertical_level(25000)\n\n# Actually getting the data\ndata_hght = ncss.get_data(gfsdata_hght)\n\n# Make into an xarray Dataset object\nds_hght = xr.open_dataset(NetCDF4DataStore(data_hght))\n\n# Query for Latest GFS Run\ngfsdata_wind = ncss.query().time(now).accept('netcdf4')\ngfsdata_wind.variables('u-component_of_wind_isobaric',\n                       'v-component_of_wind_isobaric')\n\n# Set the lat/lon box for the data you want to pull in.\n# lonlat_box(north_lat,south_lat,east_lon,west_lon)\ngfsdata_wind.lonlat_box(0, 359.9, 0, 90)\n\n# Set desired level 50000 = 50000 Pa = 500 hPa\ngfsdata_wind.vertical_level(25000)\n\n# Actually getting the data\ndata_wind = ncss.get_data(gfsdata_wind)\n\n# Make into an xarray Dataset object\nds_wind = xr.open_dataset(NetCDF4DataStore(data_wind))\n\nThe next cell will take the downloaded data and parse it to different variables\nfor use later on. Add a cyclic point using the cartopy utility add_cyclic_point\nto the longitudes (the cyclic dimension) as well as any data that is being\ncontoured or filled.\n\nlat = ds_hght.latitude.values\nlon = ds_hght.longitude.values\n\n# Converting times using the num2date function available through netCDF4\nvtimes = ds_hght.Geopotential_height_isobaric.metpy.time.values.astype('datetime64[ms]').astype('O')\n\n# Smooth the 250-hPa heights using a gaussian filter from scipy.ndimage\nhgt = ds_hght.Geopotential_height_isobaric.squeeze()\nhgt_250, lon = cutil.add_cyclic_point(hgt, coord=lon)\n\nZ_250 = mpcalc.smooth_n_point(hgt_250, 9, 2)\n\n# Calculate wind speed from u and v components, add cyclic point,\n# and smooth slightly\nu250 = ds_wind['u-component_of_wind_isobaric'].squeeze()\nv250 = ds_wind['v-component_of_wind_isobaric'].squeeze()\n\nwspd250 = mpcalc.wind_speed(u250, v250).metpy.convert_units('knots')\nwspd250 = cutil.add_cyclic_point(wspd250)\n\nsmooth_wspd250 = mpcalc.smooth_n_point(wspd250, 9, 2)\n\nThe next cell sets up the geographic details for the plot that we are going to do later.\nThis is done using the Cartopy package. We will also bring in some geographic data to\ngeo-reference the image for us.\n\ndatacrs = ccrs.PlateCarree()\nplotcrs = ccrs.NorthPolarStereo(central_longitude=-100.0)\n\n# Make a grid of lat/lon values to use for plotting.\nlons, lats = np.meshgrid(lon, lat)\n\nfig = plt.figure(1, figsize=(12., 15.))\nax = plt.subplot(111, projection=plotcrs)\n\n# Set some titles for the plots\nax.set_title('250-hPa Geopotential Heights (m)', loc='left')\nax.set_title(f'VALID: {vtimes[0]}', loc='right')\n\n# Set the extent of the image for the NH and add\n#   ax.set_extent([west long, east long, south lat, north lat])\nax.set_extent([-180, 180, 10, 90], ccrs.PlateCarree())\nax.add_feature(cfeature.COASTLINE.with_scale('50m'), edgecolor='black',\n               linewidth=0.5)\nax.add_feature(cfeature.STATES.with_scale('50m'), linewidth=0.5)\n\n# Add geopotential height contours every 120 m\nclev250 = np.arange(9000, 12000, 120)\ncs = ax.contour(lons, lats, Z_250, clev250, colors='k',\n                linewidths=1.0, linestyles='solid', transform=datacrs)\nplt.clabel(cs, fontsize=8, inline=1, inline_spacing=10, fmt='%i',\n           rightside_up=True, use_clabeltext=True)\n\n# Add colorfilled wind speed in knots every 20 kts\nclevsped250 = np.arange(50, 200, 20)\ncmap = plt.cm.get_cmap('BuPu')\ncf = ax.contourf(lons, lats, smooth_wspd250, clevsped250, cmap=cmap,\n                 extend='max', transform=datacrs)\ncbar = plt.colorbar(cf, orientation='horizontal', pad=0, aspect=50,\n                    extendrect=True)","type":"content","url":"/notebooks/synoptic/hpa-hemispheric-plot","position":1},{"hierarchy":{"lvl1":"500 hPa Geopotential Heights, Absolute Vorticity, and Winds"},"type":"lvl1","url":"/notebooks/synoptic/hpa-absolute-vorticity-winds","position":0},{"hierarchy":{"lvl1":"500 hPa Geopotential Heights, Absolute Vorticity, and Winds"},"content":"Classic 500-hPa absolute vorticity plot using NAM analysis file.\n\nThis example uses example data from the NAM analysis for 12 UTC 31\nOctober 2016 and uses xarray as the main read source with using MetPy to\ncalculate absolute vorticity and wind speed with geographic plotting\nusing Cartopy for a CONUS view of the 500-hPa geopotential heights,\nabsolute vorticity, and wind barbs.\n\nNote: NAM winds are grid relative and this example introduces a simple\nfunction to convert the grid-relative wind components to an\nearth-relative (north/east oriented winds) to enable easier plotting of\nwind barbs and calculation of absolute vorticity.\n\nImport the needed modules\n\nimport cartopy.crs as ccrs\nimport cartopy.feature as cfeature\nimport matplotlib.pyplot as plt\nimport metpy.calc as mpcalc\nfrom metpy.units import units\nimport numpy as np\nimport xarray as xr\n\n","type":"content","url":"/notebooks/synoptic/hpa-absolute-vorticity-winds","position":1},{"hierarchy":{"lvl1":"500 hPa Geopotential Heights, Absolute Vorticity, and Winds","lvl2":"Function to Compute Earth-Relative Winds"},"type":"lvl2","url":"/notebooks/synoptic/hpa-absolute-vorticity-winds#function-to-compute-earth-relative-winds","position":2},{"hierarchy":{"lvl1":"500 hPa Geopotential Heights, Absolute Vorticity, and Winds","lvl2":"Function to Compute Earth-Relative Winds"},"content":"This function takes a data array with relevant information about the\nprojection of the wind component data, along with the grid-relative\ncomponents of the wind. It outputs the earth-relative components of the\nwind.\n\ndef earth_relative_wind_components(ugrd, vgrd):\n    \"\"\"Calculate the north-relative components of the\n    wind from the grid-relative components using Cartopy\n    transform_vectors.\n\n    Parameters\n    ----------\n        ugrd : Xarray DataArray (M, N)\n            grid relative u-component of the wind\n        vgrd : Xarray DataArray (M, N)\n            grid relative v-component of the wind\n\n    Returns\n    -------\n        unr, vnr : tuple of array-like Quantity\n            The north-relative wind components in the X (East-West)\n            and Y (North-South) directions, respectively.\n    \"\"\"\n    if 'metpy_crs' not in ugrd.coords:\n        raise ValueError('No CRS in coordinate, be sure to'\n                         'use the MetPy accessor parse_cf()')\n\n    data_crs = ugrd.metpy.cartopy_crs\n\n    x = ugrd.x.values\n    y = ugrd.y.values\n\n    xx, yy = np.meshgrid(x, y)\n\n    ut, vt = ccrs.PlateCarree().transform_vectors(data_crs, xx, yy,\n                                                  ugrd.values, vgrd.values)\n\n    # Make a copy of u and v component DataArrays\n    uer = ugrd.copy()\n    ver = vgrd.copy()\n\n    # Update values with transformed winds\n    uer.values = ut\n    ver.values = vt\n\n    return uer, ver\n\n\nThe following code reads the example data using the xarray open_dataset\nfunction and prints the coordinate values that are associated with the\nvarious variables contained within the file\n\nds = xr.open_dataset('https://thredds.ucar.edu/thredds/dodsC/casestudies/'\n                     'python-gallery/NAM_20161031_1200.nc').metpy.parse_cf()\n\n","type":"content","url":"/notebooks/synoptic/hpa-absolute-vorticity-winds#function-to-compute-earth-relative-winds","position":3},{"hierarchy":{"lvl1":"500 hPa Geopotential Heights, Absolute Vorticity, and Winds","lvl2":"Data Retrieval"},"type":"lvl2","url":"/notebooks/synoptic/hpa-absolute-vorticity-winds#data-retrieval","position":4},{"hierarchy":{"lvl1":"500 hPa Geopotential Heights, Absolute Vorticity, and Winds","lvl2":"Data Retrieval"},"content":"This code retrieves the necessary data from the file and completes some\nsmoothing of the geopotential height and wind fields using the SciPy\nfunction gaussian_filter. A nicely formated valid time (vtime) variable\nis also created\n\n# Grab lat/lon values (NAM will be 2D)\nlats = ds.lat.data\nlons = ds.lon.data\n\n# Grab x, y data and make 2D for wind component plotting because\n# u- and v-components are grid relative\nx = ds['u-component_of_wind_isobaric'].x\ny = ds['u-component_of_wind_isobaric'].y\n\nxx, yy = np.meshgrid(x, y)\n\n# Grab Cartopy CRS from metadata for plotting wind barbs\ndatacrs = ds['u-component_of_wind_isobaric'].metpy.cartopy_crs\n\n# Select and grab 500-hPa geopotential heights and smooth with n-point smoother\nlevel = 500 * units.hPa\nhght_500 = mpcalc.smooth_n_point(ds.Geopotential_height_isobaric.metpy.sel(\n    vertical=level).squeeze(), 9, 50)\n\n# Select and grab 500-hPa wind components\nuwnd_500 = ds['u-component_of_wind_isobaric'].metpy.sel(\n    vertical=level).squeeze().metpy.assign_latitude_longitude()\nvwnd_500 = ds['v-component_of_wind_isobaric'].metpy.sel(\n    vertical=level).squeeze().metpy.assign_latitude_longitude()\n\n# Compute north-relative wind components for plotting purposes\nuwnd_er, vwnd_er = earth_relative_wind_components(uwnd_500, vwnd_500)\n\n# Smooth wind components as desired\nuwnd_er = mpcalc.smooth_n_point(uwnd_er, 9, 50)\nvwnd_er = mpcalc.smooth_n_point(vwnd_er, 9, 50)\n\n# Create a clean datetime object for plotting based on time\n# of Geopotential heights\nvtime = ds.time.data[0].astype('datetime64[ms]').astype('O')\n\n","type":"content","url":"/notebooks/synoptic/hpa-absolute-vorticity-winds#data-retrieval","position":5},{"hierarchy":{"lvl1":"500 hPa Geopotential Heights, Absolute Vorticity, and Winds","lvl2":"MetPy Absolute Vorticity Calculation"},"type":"lvl2","url":"/notebooks/synoptic/hpa-absolute-vorticity-winds#metpy-absolute-vorticity-calculation","position":6},{"hierarchy":{"lvl1":"500 hPa Geopotential Heights, Absolute Vorticity, and Winds","lvl2":"MetPy Absolute Vorticity Calculation"},"content":"This code calculates absolute_vorticity()\nusing the wind components and makes use of the\nxarray data object features to complete the necessary\ngrid-aware calculation.\n\n# Calculate absolute vorticity from MetPy function\navor_500 = mpcalc.absolute_vorticity(uwnd_er, vwnd_er)\n\n","type":"content","url":"/notebooks/synoptic/hpa-absolute-vorticity-winds#metpy-absolute-vorticity-calculation","position":7},{"hierarchy":{"lvl1":"500 hPa Geopotential Heights, Absolute Vorticity, and Winds","lvl2":"Map Creation"},"type":"lvl2","url":"/notebooks/synoptic/hpa-absolute-vorticity-winds#map-creation","position":8},{"hierarchy":{"lvl1":"500 hPa Geopotential Heights, Absolute Vorticity, and Winds","lvl2":"Map Creation"},"content":"This next set of code creates the plot and draws contours on a Lambert\nConformal map centered on -100 E longitude. The main view is over the\nCONUS with geopotential heights contoured every 60 m and absolute\nvorticity colorshaded (*10^5).\n\n# Set up the projection that will be used for plotting\nmapcrs = ccrs.LambertConformal(central_longitude=-100, central_latitude=35,\n                               standard_parallels=(30, 60))\n\n# Set up the projection of the data;\n# if lat/lon then PlateCarree is what you want\ndatacrs = ccrs.PlateCarree()\n\n# Start the figure and create plot axes with proper projection\nfig = plt.figure(1, figsize=(14, 12))\nax = plt.subplot(111, projection=mapcrs)\nax.set_extent([-130, -72, 20, 55], ccrs.PlateCarree())\n\n# Add geopolitical boundaries for map reference\nax.add_feature(cfeature.COASTLINE.with_scale('50m'))\nax.add_feature(cfeature.STATES.with_scale('50m'))\n\n# Absolute Vorticity colors\n# Use two different colormaps from matplotlib and combine into one color set\nclevs_500_avor = list(range(-8, 1, 1))+list(range(8, 46, 1))\ncolors1 = plt.cm.YlOrRd(np.linspace(0, 1, 48))\ncolors2 = plt.cm.BuPu(np.linspace(0.5, 0.75, 8))\ncolors = np.vstack((colors2, (1, 1, 1, 1), colors1))\n\n# Plot absolute vorticity values (multiplying by 10^5 to scale appropriately)\ncf = ax.contourf(lons, lats, avor_500*1e5, clevs_500_avor, colors=colors,\n                 extend='max', transform=datacrs)\ncb = plt.colorbar(cf, orientation='horizontal', pad=0, aspect=50,\n                  extendrect=True)\ncb.set_label('Abs. Vorticity ($s^{-1}$)')\n\n# Plot 500-hPa Geopotential Heights in meters\nclevs_500_hght = np.arange(0, 8000, 60)\ncs = ax.contour(lons, lats, hght_500, clevs_500_hght, colors='black',\n                transform=datacrs)\nplt.clabel(cs, fmt='%d')\n\n# Set up a 2D slice to reduce the number of wind barbs plotted (every 20th)\nwind_slice = (slice(None, None, 20), slice(None, None, 20))\nax.barbs(lons[wind_slice], lats[wind_slice],\n         uwnd_er.metpy.convert_units('kt')[wind_slice].values,\n         vwnd_er[wind_slice].metpy.convert_units('kt').values,\n         pivot='middle', color='black', transform=datacrs)\n\n# Plot two titles, one on right and left side\nplt.title('500-hPa NAM Geopotential Heights (m)'\n          ' and Wind Barbs (kt)', loc='left')\nplt.title(f'Valid Time: {vtime}', loc='right')","type":"content","url":"/notebooks/synoptic/hpa-absolute-vorticity-winds#map-creation","position":9},{"hierarchy":{"lvl1":"500 hPa Vorticity Advection"},"type":"lvl1","url":"/notebooks/synoptic/hpa-vorticity-advection","position":0},{"hierarchy":{"lvl1":"500 hPa Vorticity Advection"},"content":"Plot an 500-hPa map with calculating vorticity advection using MetPy calculations.\n\nBeyond just plotting 500-hPa level data, this uses calculations from metpy.calc to find\nthe vorticity and vorticity advection. Currently, this needs an extra helper function to\ncalculate the distance between lat/lon grid points.\n\nImports\n\nfrom datetime import datetime\n\nimport cartopy.crs as ccrs\nimport cartopy.feature as cfeature\nimport matplotlib.pyplot as plt\nimport metpy.calc as mpcalc\nfrom metpy.units import units\nimport numpy as np\nfrom siphon.catalog import TDSCatalog\nfrom xarray.backends import NetCDF4DataStore\nimport xarray as xr\n\n","type":"content","url":"/notebooks/synoptic/hpa-vorticity-advection","position":1},{"hierarchy":{"lvl1":"500 hPa Vorticity Advection","lvl2":"Function to Compute Earth-Relative Winds"},"type":"lvl2","url":"/notebooks/synoptic/hpa-vorticity-advection#function-to-compute-earth-relative-winds","position":2},{"hierarchy":{"lvl1":"500 hPa Vorticity Advection","lvl2":"Function to Compute Earth-Relative Winds"},"content":"This function takes a data array with relevant information about the\nprojection of the wind component data, along with the grid-relative\ncomponents of the wind. It outputs the earth-relative components of the\nwind.\n\ndef earth_relative_wind_components(ugrd, vgrd):\n    \"\"\"Calculate the north-relative components of the\n    wind from the grid-relative components using Cartopy\n    transform_vectors.\n\n    Parameters\n    ----------\n        ugrd : Xarray DataArray (M, N)\n            grid relative u-component of the wind\n        vgrd : Xarray DataArray (M, N)\n            grid relative v-component of the wind\n\n    Returns\n    -------\n        unr, vnr : tuple of array-like Quantity\n            The north-relative wind components in the X (East-West)\n            and Y (North-South) directions, respectively.\n    \"\"\"\n    if 'metpy_crs' not in ugrd.coords:\n        raise ValueError('No CRS in coordinate, be sure to use'\n                         'the MetPy accessor parse_cf()')\n\n    data_crs = ugrd.metpy.cartopy_crs\n\n    x = ugrd.x.values\n    y = ugrd.y.values\n\n    xx, yy = np.meshgrid(x, y)\n\n    ut, vt = ccrs.PlateCarree().transform_vectors(data_crs, xx, yy,\n                                                  ugrd.values, vgrd.values)\n\n    # Make a copy of u and v component DataArrays\n    uer = ugrd.copy()\n    ver = vgrd.copy()\n\n    # Update values with transformed winds\n    uer.values = ut\n    ver.values = vt\n\n    return uer, ver\n\n\n","type":"content","url":"/notebooks/synoptic/hpa-vorticity-advection#function-to-compute-earth-relative-winds","position":3},{"hierarchy":{"lvl1":"500 hPa Vorticity Advection","lvl2":"Data Aquisition"},"type":"lvl2","url":"/notebooks/synoptic/hpa-vorticity-advection#data-aquisition","position":4},{"hierarchy":{"lvl1":"500 hPa Vorticity Advection","lvl2":"Data Aquisition"},"content":"\n\ndt = datetime(2016, 4, 16, 18)\n\n# Assemble our URL to the THREDDS Data Server catalog,\n# and access our desired dataset within via NCSS\nbase_url = 'https://www.ncei.noaa.gov/thredds/catalog/model-namanl-old/'\ncat = TDSCatalog(f'{base_url}{dt:%Y%m}/{dt:%Y%m%d}/catalog.xml')\nncss = cat.datasets[f'namanl_218_{dt:%Y%m%d}_{dt:%H}00_000.grb'].subset()\n\n# Query for Latest GFS Run\nquery = ncss.query()\n\nquery.time(dt)\nquery.accept('netcdf')\nquery.variables('Geopotential_height_isobaric',\n                'u-component_of_wind_isobaric',\n                'v-component_of_wind_isobaric')\n\n# Obtain our queried data\ndata = ncss.get_data(query)\nds_data = xr.open_dataset(NetCDF4DataStore(data)).metpy.parse_cf()\nds = ds_data.metpy.assign_latitude_longitude()\n\ntimes = ds.Geopotential_height_isobaric.metpy.time\nvtime = times.values.squeeze().astype('datetime64[ms]').astype('O')\n\nlev_500 = 500 * units.hPa\n\nhght_500 = ds.Geopotential_height_isobaric.metpy.sel(\n    vertical=lev_500).squeeze()\nhght_500 = mpcalc.smooth_gaussian(hght_500, 4)\n\nuwnd_500 = ds['u-component_of_wind_isobaric'].metpy.sel(\n    vertical=lev_500).squeeze()\nvwnd_500 = ds['v-component_of_wind_isobaric'].metpy.sel(\n    vertical=lev_500).squeeze()\n\n# Compute north-relative wind components for calculation purposes\nuwnd_500er, vwnd_500er = earth_relative_wind_components(uwnd_500, vwnd_500)\n\n","type":"content","url":"/notebooks/synoptic/hpa-vorticity-advection#data-aquisition","position":5},{"hierarchy":{"lvl1":"500 hPa Vorticity Advection","lvl2":"Begin Data Calculations"},"type":"lvl2","url":"/notebooks/synoptic/hpa-vorticity-advection#begin-data-calculations","position":6},{"hierarchy":{"lvl1":"500 hPa Vorticity Advection","lvl2":"Begin Data Calculations"},"content":"\n\navor = mpcalc.vorticity(uwnd_500er, vwnd_500er)\n\navor = mpcalc.smooth_n_point(avor, 9, 10) * 1e5\n\nvort_adv = mpcalc.advection(avor, uwnd_500er, vwnd_500er) * 1e4\n\n","type":"content","url":"/notebooks/synoptic/hpa-vorticity-advection#begin-data-calculations","position":7},{"hierarchy":{"lvl1":"500 hPa Vorticity Advection","lvl2":"Map Creation"},"type":"lvl2","url":"/notebooks/synoptic/hpa-vorticity-advection#map-creation","position":8},{"hierarchy":{"lvl1":"500 hPa Vorticity Advection","lvl2":"Map Creation"},"content":"\n\n# Set up Coordinate System for Plot and Transforms\ndatacrs = ds.Geopotential_height_isobaric.metpy.cartopy_crs\nplotcrs = ccrs.LambertConformal(central_latitude=45., central_longitude=-100.,\n                                standard_parallels=[30, 60])\n\nfig = plt.figure(1, figsize=(12., 14.))\nax = plt.subplot(111, projection=plotcrs)\n\n# Plot Titles\nplt.title(r'500-hPa Heights (m), AVOR$*10^5$ ($s^{-1}$),'\n          'AVOR Adv$*10^9$ ($s^{-2}$)', loc='left')\nplt.title(f'VALID: {vtime}', loc='right')\n\n# Plot Background\nax.set_extent([235., 290., 20., 58.], ccrs.PlateCarree())\nax.coastlines('50m', edgecolor='black', linewidth=0.75)\nax.add_feature(cfeature.STATES, linewidth=.5)\n\n# Plot Height Contours\nclev500 = np.arange(5100, 6061, 60)\ncs = ax.contour(hght_500.longitude, hght_500.latitude,\n                hght_500, clev500,\n                colors='black', linewidths=1.0,\n                linestyles='solid', transform=ccrs.PlateCarree())\nplt.clabel(cs, fontsize=10, inline=1, inline_spacing=10, fmt='%i',\n           rightside_up=True, use_clabeltext=True)\n\n# Plot Absolute Vorticity Contours\nclevvort500 = np.arange(-9, 50, 5)\ncs2 = ax.contour(avor.longitude, avor.latitude,\n                 avor, clevvort500,\n                 colors='grey', linewidths=1.25, linestyles='dashed',\n                 transform=ccrs.PlateCarree())\nplt.clabel(cs2, fontsize=10, inline=1, inline_spacing=10, fmt='%i',\n           rightside_up=True, use_clabeltext=True)\n\n# Plot Colorfill of Vorticity Advection\nclev_avoradv = np.arange(-30, 31, 5)\ncf = ax.contourf(vort_adv.longitude, vort_adv.latitude, vort_adv,\n                 clev_avoradv[clev_avoradv != 0], extend='both',\n                 cmap='bwr', transform=ccrs.PlateCarree())\ncb = plt.colorbar(cf, orientation='horizontal', pad=0, aspect=50,\n                  extendrect='True', ticks=clev_avoradv)\ncb.set_label(r'$1/s^2$', size='large')\n\n# Plot Wind Barbs\n# Transform Vectors and plot wind barbs.\nwind_slice = (slice(None, None, 20), slice(None, None, 20))\nxx, yy = np.meshgrid(uwnd_500.x.values[wind_slice[0]],\n                     uwnd_500.y.values[wind_slice[0]])\nax.barbs(xx, yy, uwnd_500.values[wind_slice], vwnd_500.values[wind_slice],\n         length=6, pivot='middle', transform=datacrs)","type":"content","url":"/notebooks/synoptic/hpa-vorticity-advection#map-creation","position":9},{"hierarchy":{"lvl1":"850-hPa Geopotential Heights, Temperature, Frontogenesis, and Winds"},"type":"lvl1","url":"/notebooks/synoptic/hpa-frontogenesis","position":0},{"hierarchy":{"lvl1":"850-hPa Geopotential Heights, Temperature, Frontogenesis, and Winds"},"content":"Frontogenesis at 850-hPa with Geopotential Heights, Temperature, and\nWinds\n\nThis example uses example data from the GFS analysis for 12 UTC 26\nOctober 2010 and uses xarray as the main read source with using MetPy to\ncalculate frontogenesis and wind speed with geographic plotting using\nCartopy for a CONUS view.\n\nImport the needed modules.\n\nimport cartopy.crs as ccrs\nimport cartopy.feature as cfeature\nimport matplotlib.pyplot as plt\nimport metpy.calc as mpcalc\nfrom metpy.units import units\nimport numpy as np\nimport xarray as xr\n\nUse Xarray to access GFS data from THREDDS resource and uses\nmetpy accessor to parse file to make it easy to pull data using\ncommon coordinate names (e.g., vertical) and attach units.\n\nds = xr.open_dataset('https://thredds.ucar.edu/thredds/dodsC/casestudies/'\n                     'python-gallery/GFS_20101026_1200.nc').metpy.parse_cf()\n\nSubset data based on latitude and longitude values, calculate potential\ntemperature for frontogenesis calculation.\n\n# Set subset slice for the geographic extent of data to limit download\nlon_slice = slice(200, 350)\nlat_slice = slice(85, 10)\n\n# Grab lat/lon values (GFS will be 1D)\nlats = ds.lat.sel(lat=lat_slice).values\nlons = ds.lon.sel(lon=lon_slice).values\n\nlevel = 850 * units.hPa\nhght_850 = ds.Geopotential_height_isobaric.metpy.sel(\n    vertical=level, lat=lat_slice, lon=lon_slice).squeeze()\ntmpk_850 = ds.Temperature_isobaric.metpy.sel(\n    vertical=level, lat=lat_slice, lon=lon_slice).squeeze()\nuwnd_850 = ds['u-component_of_wind_isobaric'].metpy.sel(\n    vertical=level, lat=lat_slice, lon=lon_slice).squeeze()\nvwnd_850 = ds['v-component_of_wind_isobaric'].metpy.sel(\n    vertical=level, lat=lat_slice, lon=lon_slice).squeeze()\n\n# Convert temperatures to degree Celsius for plotting purposes\ntmpc_850 = tmpk_850.metpy.convert_units('degC')\n\n# Calculate potential temperature for frontogenesis calculation\nthta_850 = mpcalc.potential_temperature(level, tmpk_850)\n\n# Get a sensible datetime format\nvtime = ds.time.data[0].astype('datetime64[ms]').astype('O')\n\n","type":"content","url":"/notebooks/synoptic/hpa-frontogenesis","position":1},{"hierarchy":{"lvl1":"850-hPa Geopotential Heights, Temperature, Frontogenesis, and Winds","lvl2":"Calculate frontogenesis"},"type":"lvl2","url":"/notebooks/synoptic/hpa-frontogenesis#calculate-frontogenesis","position":2},{"hierarchy":{"lvl1":"850-hPa Geopotential Heights, Temperature, Frontogenesis, and Winds","lvl2":"Calculate frontogenesis"},"content":"Frontogenesis calculation in MetPy requires temperature, wind\ncomponents, and grid spacings. First compute the grid deltas using MetPy\nfunctionality, then put it all together in the frontogenesis function.\n\nNote: MetPy will give the output with SI units, but typically\nfrontogenesis (read: GEMPAK) output this variable with units of K per\n100 km per 3 h; a conversion factor is included here to use at plot time\nto reflect those units.\n\nfronto_850 = mpcalc.frontogenesis(thta_850, uwnd_850, vwnd_850)\n\n# A conversion factor to get frontogensis units of K per 100 km per 3 h\nconvert_to_per_100km_3h = 1000*100*3600*3\n\n","type":"content","url":"/notebooks/synoptic/hpa-frontogenesis#calculate-frontogenesis","position":3},{"hierarchy":{"lvl1":"850-hPa Geopotential Heights, Temperature, Frontogenesis, and Winds","lvl2":"Plotting Frontogenesis"},"type":"lvl2","url":"/notebooks/synoptic/hpa-frontogenesis#plotting-frontogenesis","position":4},{"hierarchy":{"lvl1":"850-hPa Geopotential Heights, Temperature, Frontogenesis, and Winds","lvl2":"Plotting Frontogenesis"},"content":"Using a Lambert Conformal projection from Cartopy to plot 850-hPa\nvariables including frontogenesis.\n\n# Set map projection\nmapcrs = ccrs.LambertConformal(central_longitude=-100, central_latitude=35,\n                               standard_parallels=(30, 60))\n\n# Set projection of the data (GFS is lat/lon)\ndatacrs = ccrs.PlateCarree()\n\n# Start figure and limit the graphical area extent\nfig = plt.figure(1, figsize=(14, 12))\nax = plt.subplot(111, projection=mapcrs)\nax.set_extent([-130, -72, 20, 55], ccrs.PlateCarree())\n\n# Add map features of Coastlines and States\nax.add_feature(cfeature.COASTLINE.with_scale('50m'))\nax.add_feature(cfeature.STATES.with_scale('50m'))\n\n# Plot 850-hPa Frontogenesis\nclevs_tmpc = np.arange(-40, 41, 2)\ncf = ax.contourf(lons, lats, fronto_850*convert_to_per_100km_3h,\n                 np.arange(-8, 8.5, 0.5), cmap=plt.cm.bwr, extend='both',\n                 transform=datacrs)\ncb = plt.colorbar(cf, orientation='horizontal', pad=0, aspect=50,\n                  extendrect=True)\ncb.set_label('Frontogenesis K / 100 km / 3 h')\n\n# Plot 850-hPa Temperature in Celsius\ncsf = ax.contour(lons, lats, tmpc_850, clevs_tmpc, colors='grey',\n                 linestyles='dashed', transform=datacrs)\nplt.clabel(csf, fmt='%d')\n\n# Plot 850-hPa Geopotential Heights\nclevs_850_hght = np.arange(0, 8000, 30)\ncs = ax.contour(lons, lats, hght_850, clevs_850_hght, colors='black',\n                transform=datacrs)\nplt.clabel(cs, fmt='%d')\n\n# Plot 850-hPa Wind Barbs only plotting every fifth barb\nwind_slice = (slice(None, None, 5), slice(None, None, 5))\nax.barbs(lons[wind_slice[0]], lats[wind_slice[1]],\n         uwnd_850[wind_slice].metpy.convert_units('kt').values,\n         vwnd_850[wind_slice].metpy.convert_units('kt').values,\n         color='black', transform=datacrs)\n\n# Plot some titles\nplt.title('GFS 850-hPa Geopotential Heights (m), Temp (C), and Winds',\n          loc='left')\nplt.title(f'Valid Time: {vtime}', loc='right')","type":"content","url":"/notebooks/synoptic/hpa-frontogenesis#plotting-frontogenesis","position":5},{"hierarchy":{"lvl1":"QVector Example"},"type":"lvl1","url":"/notebooks/synoptic/hpa-qvectors","position":0},{"hierarchy":{"lvl1":"QVector Example"},"content":"Computing Q-vectors and Q-vector divergence for a real case.\n\nBy: Kevin Goebbert\n\nThis example uses GFS output to compute the 850-hPa Q-vectors and\nQ-vector divergence for 12 UTC 26 October 2010.\n\nImport needed modules\n\nimport cartopy.crs as ccrs\nimport cartopy.feature as cfeature\nimport matplotlib.pyplot as plt\nimport metpy.calc as mpcalc\nfrom metpy.plots import named_areas\nfrom metpy.units import units\nimport numpy as np\nimport xarray as xr\n\nUse Xarray to access GFS data from THREDDS resource and uses\nmetpy accessor to parse file to make it easy to pull data using\ncommon coordinate names (e.g., vertical) and attach units.\n\nds = xr.open_dataset('https://thredds.ucar.edu/thredds/dodsC/casestudies/'\n                     'python-gallery/GFS_20101026_1200.nc')\n\nSubset data based on latitude and longitude values and select only data\nfrom 850 hPa\n\n# Set subset slice for the geographic extent of data to limit download\nlon_slice = slice(200, 350)\nlat_slice = slice(85, 10)\n\n# Grab data and smooth using a nine-point filter applied 50 times to grab\n# the synoptic signal\nlevel = 850 * units.hPa\nhght_850 = mpcalc.smooth_n_point(ds.Geopotential_height_isobaric.metpy.sel(\n    vertical=level, lat=lat_slice, lon=lon_slice).squeeze(), 9, 50)\ntmpk_850 = mpcalc.smooth_n_point(ds.Temperature_isobaric.metpy.sel(\n    vertical=level, lat=lat_slice, lon=lon_slice).squeeze(), 9, 25)\nuwnd_850 = mpcalc.smooth_n_point(ds['u-component_of_wind_isobaric'].metpy.sel(\n    vertical=level, lat=lat_slice, lon=lon_slice).squeeze(), 9, 50)\nvwnd_850 = mpcalc.smooth_n_point(ds['v-component_of_wind_isobaric'].metpy.sel(\n    vertical=level, lat=lat_slice, lon=lon_slice).squeeze(), 9, 50)\n\n# Grab lat/lon values (GFS will be 1D) from a subset variable\nlons, lats = hght_850.lon, hght_850.lat\n\n# Convert temperatures to degree Celsius for plotting purposes\ntmpc_850 = tmpk_850.metpy.convert_units('degC')\n\n# Get a sensible datetime format\nvtime = ds.time.data[0].astype('datetime64[ms]').astype('O')\n\n","type":"content","url":"/notebooks/synoptic/hpa-qvectors","position":1},{"hierarchy":{"lvl1":"QVector Example","lvl2":"Compute Q-vectors"},"type":"lvl2","url":"/notebooks/synoptic/hpa-qvectors#compute-q-vectors","position":2},{"hierarchy":{"lvl1":"QVector Example","lvl2":"Compute Q-vectors"},"content":"Use the MetPy module to compute Q-vectors from requisite data and\nadditionally compute the Q-vector divergence (and multiply by -2) to\ncalculate the right hand side forcing of the Q-G Omega equation.\n\n# Compute grid spacings for data\n#dx, dy = mpcalc.lat_lon_grid_deltas(lons, lats)\n\n# Compute the Q-vector components\nuqvect, vqvect = mpcalc.q_vector(uwnd_850, vwnd_850, tmpk_850, 850*units.hPa)\n\n# Compute the divergence of the Q-vectors calculated above\nq_div = -2*mpcalc.divergence(uqvect, vqvect)\n\n","type":"content","url":"/notebooks/synoptic/hpa-qvectors#compute-q-vectors","position":3},{"hierarchy":{"lvl1":"QVector Example","lvl2":"Plot Data"},"type":"lvl2","url":"/notebooks/synoptic/hpa-qvectors#plot-data","position":4},{"hierarchy":{"lvl1":"QVector Example","lvl2":"Plot Data"},"content":"Use Cartopy to plot data on a map using a Lambert Conformal projection.\n\n# Set the map projection (how the data will be displayed)\nmapcrs = named_areas['uslcc'].projection\n\n# Set the data project (GFS is lat/lon format)\ndatacrs = ccrs.PlateCarree()\n\n# Start the figure and set an extent to only display a smaller graphics area\nfig = plt.figure(1, figsize=(14, 12))\nax = plt.subplot(111, projection=mapcrs)\nax.set_extent(named_areas['uslcc'].bounds, ccrs.PlateCarree())\n\n# Add map features to plot coastlines and state boundaries\nax.add_feature(cfeature.COASTLINE.with_scale('50m'))\nax.add_feature(cfeature.STATES.with_scale('50m'))\n\n# Plot 850-hPa Q-Vector Divergence and scale\nclevs_850_tmpc = np.arange(-40, 41, 2)\nclevs_qdiv = list(range(-35, -4, 5))+list(range(5, 36, 5))\ncf = ax.contourf(lons, lats, q_div*1e18, clevs_qdiv, cmap=plt.cm.bwr,\n                 extend='both', transform=datacrs)\ncb = plt.colorbar(cf, orientation='horizontal', pad=0, aspect=50,\n                  extendrect=True, ticks=clevs_qdiv)\ncb.set_label('Q-Vector Div. (*10$^{18}$ m s$^{-1}$ kg$^{-1}$)')\n\n# Plot 850-hPa Temperatures\ncsf = ax.contour(lons, lats, tmpc_850, clevs_850_tmpc, colors='grey',\n                 linestyles='dashed', transform=datacrs)\nplt.clabel(csf, fmt='%d')\n\n# Plot 850-hPa Geopotential Heights\nclevs_850_hght = np.arange(0, 8000, 30)\ncs = ax.contour(lons, lats, hght_850, clevs_850_hght, colors='black',\n                transform=datacrs)\nplt.clabel(cs, fmt='%d')\n\n# Plot 850-hPa Q-vectors, scale to get nice sized arrows\nwind_slice = (slice(None, None, 5), slice(None, None, 5))\nax.quiver(lons[wind_slice[0]], lats[wind_slice[1]],\n          uqvect[wind_slice].values,\n          vqvect[wind_slice].values,\n          pivot='mid', color='black',\n          scale=5e-12, scale_units='inches',\n          transform=datacrs)\n\n# Add some titles\nplt.title('850-hPa GFS Geo. Heights (m), Temp (C),'\n          ' and Q-Vectors (m$^2$ kg$^{-1}$ s$^{-1}$)', loc='left')\nplt.title(f'Valid Time: {vtime}', loc='right')","type":"content","url":"/notebooks/synoptic/hpa-qvectors#plot-data","position":5},{"hierarchy":{"lvl1":"850 hPa Temperature Advection"},"type":"lvl1","url":"/notebooks/synoptic/hpa-temperature-advection","position":0},{"hierarchy":{"lvl1":"850 hPa Temperature Advection"},"content":"Plot an 850 hPa map with calculating advection using MetPy.\n\nBeyond just plotting 850-hPa level data, this uses calculations from metpy.calc to find\nthe temperature advection. Currently, this needs an extra helper function to calculate\nthe distance between lat/lon grid points.\n\nImports\n\nfrom datetime import datetime\n\nimport cartopy.crs as ccrs\nimport cartopy.feature as cfeature\nimport matplotlib.pyplot as plt\nimport metpy.calc as mpcalc\nimport numpy as np\nfrom metpy.units import units\nfrom siphon.catalog import TDSCatalog\nfrom xarray.backends import NetCDF4DataStore\nimport xarray as xr\n\n","type":"content","url":"/notebooks/synoptic/hpa-temperature-advection","position":1},{"hierarchy":{"lvl1":"850 hPa Temperature Advection","lvl2":"Create NCSS object to access the NetcdfSubset"},"type":"lvl2","url":"/notebooks/synoptic/hpa-temperature-advection#create-ncss-object-to-access-the-netcdfsubset","position":2},{"hierarchy":{"lvl1":"850 hPa Temperature Advection","lvl2":"Create NCSS object to access the NetcdfSubset"},"content":"Data from NCEI GFS 0.5 deg Analysis Archive\n\ndt = datetime(2017, 4, 5, 12)\n\n# Assemble our URL to the THREDDS Data Server catalog,\n# and access our desired dataset within via NCSS\nbase_url = 'https://www.ncei.noaa.gov/thredds/model-gfs-g4-anl-files-old/'\ncat = TDSCatalog(f'{base_url}{dt:%Y%m}/{dt:%Y%m%d}/catalog.xml')\nncss = cat.datasets[f'gfsanl_4_{dt:%Y%m%d}_{dt:%H}00_000.grb2'].subset()\n\n# Create NCSS query for our desired time, region, and data variables\nquery = ncss.query()\n\nquery.time(dt)\nquery.lonlat_box(north=65, south=15, east=310, west=220)\nquery.accept('netcdf')\nquery.variables('Geopotential_height_isobaric',\n                'Temperature_isobaric',\n                'u-component_of_wind_isobaric',\n                'v-component_of_wind_isobaric')\n\n# Obtain the queried data\ndata = ncss.get_data(query)\n\n# Make into an xarray Dataset object\nds = xr.open_dataset(NetCDF4DataStore(data)).metpy.parse_cf()\n\n# Pull out variables you want to use\nlevel = 850 * units.hPa\nhght_850 = ds.Geopotential_height_isobaric.metpy.sel(\n    vertical=level).squeeze()\ntemp_850 = ds.Temperature_isobaric.metpy.sel(\n    vertical=level).squeeze()\nu_wind_850 = ds['u-component_of_wind_isobaric'].metpy.sel(\n    vertical=level).squeeze()\nv_wind_850 = ds['v-component_of_wind_isobaric'].metpy.sel(\n    vertical=level).squeeze()\ntime = hght_850.metpy.time\nlat = ds.lat.values\nlon = ds.lon.values\n\n# Convert number of hours since the reference time into an actual date\nvtime = time.values.astype('datetime64[ms]').astype('O')\n\n# Combine 1D latitude and longitudes into a 2D grid of locations\nlon_2d, lat_2d = np.meshgrid(lon, lat)\n\n","type":"content","url":"/notebooks/synoptic/hpa-temperature-advection#create-ncss-object-to-access-the-netcdfsubset","position":3},{"hierarchy":{"lvl1":"850 hPa Temperature Advection","lvl2":"Begin data calculations"},"type":"lvl2","url":"/notebooks/synoptic/hpa-temperature-advection#begin-data-calculations","position":4},{"hierarchy":{"lvl1":"850 hPa Temperature Advection","lvl2":"Begin data calculations"},"content":"\n\n# Calculate temperature advection using metpy function\nadv = mpcalc.advection(temp_850, u_wind_850, v_wind_850)\n\n# Smooth heights and advection a little\n# Be sure to only put in a 2D lat/lon or Y/X array for smoothing\nZ_850 = mpcalc.smooth_gaussian(hght_850, 2)\nadv = mpcalc.smooth_gaussian(adv, 2)\n\n","type":"content","url":"/notebooks/synoptic/hpa-temperature-advection#begin-data-calculations","position":5},{"hierarchy":{"lvl1":"850 hPa Temperature Advection","lvl2":"Begin map creation"},"type":"lvl2","url":"/notebooks/synoptic/hpa-temperature-advection#begin-map-creation","position":6},{"hierarchy":{"lvl1":"850 hPa Temperature Advection","lvl2":"Begin map creation"},"content":"\n\n# Set Projection of Data\ndatacrs = ccrs.PlateCarree()\n\n# Set Projection of Plot\nplotcrs = ccrs.LambertConformal(central_latitude=45,\n                                central_longitude=-100, standard_parallels=[30, 60])\n\n# Create new figure\nfig = plt.figure(figsize=(14, 12))\n\n# Add the map and set the extent\nax = plt.subplot(111, projection=plotcrs)\nplt.title(f'850mb Temperature Advection for {vtime:%d %B %Y %H:%MZ}',\n          fontsize=16)\nax.set_extent([235., 290., 20., 55.])\n\n# Add state/country boundaries to plot\nax.add_feature(cfeature.STATES)\nax.add_feature(cfeature.BORDERS)\n\n# Plot Height Contours\nclev850 = np.arange(900, 3000, 30)\ncs = ax.contour(lon_2d, lat_2d, Z_850, clev850, colors='black', linewidths=1.5,\n                linestyles='solid', transform=datacrs)\nplt.clabel(cs, fontsize=10, inline=1, inline_spacing=10, fmt='%i',\n           rightside_up=True, use_clabeltext=True)\n\n# Plot Temperature Contours\nclevtemp850 = np.arange(-20, 20, 2)\ncs2 = ax.contour(lon_2d, lat_2d, temp_850.metpy.convert_units('degC'),\n                 clevtemp850, colors='grey', linewidths=1.25,\n                 linestyles='dashed', transform=datacrs)\nplt.clabel(cs2, fontsize=10, inline=1, inline_spacing=10, fmt='%i',\n           rightside_up=True, use_clabeltext=True)\n\n# Plot Colorfill of Temperature Advection\ncint = np.arange(-8, 9)\ncf = ax.contourf(lon_2d, lat_2d, 3*adv.metpy.convert_units('delta_degC/hour'),\n                 cint[cint != 0],\n                 extend='both', cmap='bwr', transform=datacrs)\ncb = plt.colorbar(cf, orientation='horizontal', pad=0, aspect=50,\n                  extendrect=True, ticks=cint)\ncb.set_label(r'$^{o}C/3h$', size='large')\n\nwind_slice = (slice(None, None, 10), slice(None, None, 10))\n# Plot Wind Barbs\nax.barbs(lon_2d[wind_slice], lat_2d[wind_slice],\n         u_wind_850.metpy.convert_units('kt').values[wind_slice],\n         v_wind_850.metpy.convert_units('kt').values[wind_slice],\n         length=6, pivot='middle', transform=datacrs);","type":"content","url":"/notebooks/synoptic/hpa-temperature-advection#begin-map-creation","position":7},{"hierarchy":{"lvl1":"Geostrophic and Ageostrophic Wind"},"type":"lvl1","url":"/notebooks/synoptic/ageostrophic-wind-example","position":0},{"hierarchy":{"lvl1":"Geostrophic and Ageostrophic Wind"},"content":"Plot a 1000-hPa map calculating the geostrophic from MetPy and finding the\nageostrophic wind from the total wind and the geostrophic wind.\n\nThis uses the geostrophic wind calculation from metpy.calc to find\nthe geostrophic wind, then performs the simple subtraction to find the ageostrophic\nwind. Currently, this needs an extra helper function to calculate\nthe distance between lat/lon grid points.\n\nAdditionally, we utilize the ndimage.zoom method for smoothing the 1000-hPa\nheight contours without smoothing the data.\n\nImports\n\nfrom datetime import datetime, timedelta\n\nimport cartopy.crs as ccrs\nimport cartopy.feature as cfeature\nimport matplotlib.pyplot as plt\nimport metpy.calc as mpcalc\nimport numpy as np\nfrom scipy import ndimage\nfrom siphon.catalog import TDSCatalog\nfrom xarray.backends import NetCDF4DataStore\nimport xarray as xr\n\nSet up access to the data\n\ndt = datetime(2016, 8, 22, 18)\nforecast_hour = 3\nh = timedelta(hours=forecast_hour)\n\n# Assemble our URL to the THREDDS Data Server catalog,\n# and access our desired dataset within via NCSS\nbase_url = 'https://www.ncei.noaa.gov/thredds/model-gfs-g4-anl-files-old/'\ncat = TDSCatalog(f'{base_url}{dt:%Y%m}/{dt:%Y%m%d}/catalog.xml')\nncss = cat.datasets[f'gfsanl_4_{dt:%Y%m%d}_{dt:%H}'\n                    f'00_00{forecast_hour}.grb2'].subset()\n\n# Create NCSS query for our desired time, region, and data variables\nquery = ncss.query()\n\nquery.lonlat_box(north=50, south=30, east=-80, west=-115)\nquery.time(dt + h)\nquery.variables('Geopotential_height_isobaric',\n                'u-component_of_wind_isobaric',\n                'v-component_of_wind_isobaric')\nquery.vertical_level(100000)\n\ndata = ncss.get_data(query)\n\nds = xr.open_dataset(NetCDF4DataStore(data)).metpy.parse_cf()\n\n# Pull out variables you want to use\nheight = ds.Geopotential_height_isobaric.squeeze()\nu_wind = ds['u-component_of_wind_isobaric'].squeeze().metpy.quantify()\nv_wind = ds['v-component_of_wind_isobaric'].squeeze().metpy.quantify()\n\nvtime = height.time.values.squeeze().astype('datetime64[ms]').astype('O')\n\nlat = ds.lat\nlon = ds.lon\n\n# Combine 1D latitude and longitudes into a 2D grid of locations\nlon_2d, lat_2d = np.meshgrid(lon, lat)\n\n# Smooth height data\nheight = mpcalc.smooth_n_point(height, 9, 3)\n\n# Compute the geostrophic wind\ngeo_wind_u, geo_wind_v = mpcalc.geostrophic_wind(height)\n\n# Calculate ageostrophic wind components\nageo_wind_u = u_wind - geo_wind_u\nageo_wind_v = v_wind - geo_wind_v\n\n# Create new figure\nfig = plt.figure(figsize=(15, 10), facecolor='black')\n\n# Add the map and set the extent\nax = plt.axes(projection=ccrs.PlateCarree())\nax.set_extent([-105., -93., 35., 43.])\nax.patch.set_fill(False)\n\n# Add state boundaries to plot\nax.add_feature(cfeature.STATES, edgecolor='white', linewidth=2)\n\n# Contour the heights every 10 m\ncontours = np.arange(10, 200, 10)\n# Because we have a very local graphics area, the contours have joints\n# to smooth those out we can use `ndimage.zoom`\nzoom_500 = mpcalc.zoom_xarray(height, 5)\nc = ax.contour(zoom_500.lon, zoom_500.lat, zoom_500, levels=contours,\n               colors='red', linewidths=4)\nax.clabel(c, fontsize=12, inline=1, inline_spacing=3, fmt='%i')\n\n# Set up parameters for quiver plot. The slices below are used to\n# subset the data (here taking every 4th point in x and y). The\n# quiver_kwargs are parameters to control the appearance of the\n# quiver so that they stay consistent between the calls.\nquiver_slices = (slice(None, None, 2), slice(None, None, 2))\nquiver_kwargs = {'headlength': 4, 'headwidth': 3, 'angles': 'uv',\n                 'scale_units': 'xy', 'scale': 20}\n\n# Plot the wind vectors\nwind = ax.quiver(lon_2d[quiver_slices], lat_2d[quiver_slices],\n                 u_wind[quiver_slices], v_wind[quiver_slices],\n                 color='blue', **quiver_kwargs)\ngeo = ax.quiver(lon_2d[quiver_slices], lat_2d[quiver_slices],\n                geo_wind_u[quiver_slices], geo_wind_v[quiver_slices],\n                color='darkorchid', **quiver_kwargs)\nageo = ax.quiver(lon_2d[quiver_slices], lat_2d[quiver_slices],\n                 ageo_wind_u[quiver_slices], ageo_wind_v[quiver_slices],\n                 color='lime', **quiver_kwargs)\n\n# Add a title to the plot\nplt.title('1000mb Geopotential Heights(m), Wind(blue), '\n          'Geostrophic Wind(purple), and \\n Ageostrophic Wind(green) '\n          f'for {vtime:%d %B %Y %H:%MZ}', color='white', size=14)","type":"content","url":"/notebooks/synoptic/ageostrophic-wind-example","position":1},{"hierarchy":{"lvl1":"Analytic 300-hPa Trough"},"type":"lvl1","url":"/notebooks/synoptic/analytic-300hpa-trough","position":0},{"hierarchy":{"lvl1":"Analytic 300-hPa Trough"},"content":"import matplotlib.pyplot as plt\nimport metpy.calc as mpcalc\nfrom metpy.units import units\nimport numpy as np\n\nBelow are three definitions to create an analytic 300-hPa trough roughly\nbased on the Sanders Analytic Model with modified coefficients to create\ndifferent style waves.\n\ndef single_300hPa_trough(parameter='hght'):\n    \"\"\" Single trough with heights and Temperatures based on Sanders Analytic Model\n    \"\"\"\n    X = np.linspace(.25, .75, 101)\n    Y = np.linspace(.25, .75, 101)\n\n    x, y = np.meshgrid(X, Y)\n\n    p = 4\n    q = 2\n\n    if parameter == 'hght':\n        return (9240 + 100 * np.cos(p * x * np.pi) * np.cos(q * y * np.pi)\n                + 200 * np.cos(y * np.pi) + 300 * y * np.cos(x * np.pi + np.pi / 2))\n    elif parameter == 'temp':\n        return (-50 + 2 * np.cos(p * x * np.pi) * np.cos(q * y * np.pi)\n                + 2 * np.cos(y * np.pi) + 0.5 * y * np.cos(x * np.pi + np.pi / 2))\n\n\ndef lifting_300hPa_trough(parameter='hght'):\n    \"\"\" Lifting trough with heights and Temperatures based on Sanders Analytic Model\n    \"\"\"\n    X = np.linspace(.25, .75, 101)\n    Y = np.linspace(.25, .75, 101)\n\n    x, y = np.meshgrid(X, Y)\n\n    p = 4\n    q = 2\n\n    if parameter == 'hght':\n        return (9240 + 150 * np.cos(p * x * np.pi) * np.cos(q * y * np.pi)\n                + 200 * np.cos(y * np.pi) + 400 * y * np.cos(x * np.pi + np.pi))\n    elif parameter == 'temp':\n        return (-50 + 2 * np.cos(p * x * np.pi) * np.cos(q * y * np.pi)\n                + 2 * np.cos(y * np.pi) + 5 * y * np.cos(x * np.pi + np.pi))\n\n\ndef digging_300hPa_trough(parameter='hght'):\n    \"\"\" Digging trough with heights and Temperatures based on Sanders Analytic Model\n    \"\"\"\n    X = np.linspace(.25, .75, 101)\n    Y = np.linspace(.25, .75, 101)\n\n    x, y = np.meshgrid(X, Y)\n\n    p = 4\n    q = 2\n\n    if parameter == 'hght':\n        return (9240 + 150 * np.cos(p * x * np.pi) * np.cos(q * y * np.pi)\n                + 200 * np.cos(y * np.pi) + 400 * y * np.sin(x * np.pi + 5 * np.pi / 2))\n    elif parameter == 'temp':\n        return (-50 + 2 * np.cos(p * x * np.pi) * np.cos(q * y * np.pi)\n                + 2 * np.cos(y * np.pi) + 5 * y * np.sin(x * np.pi + np.pi / 2))\n\nCall the appropriate definition to develop the desired wave.\n\n# Single Trough\nZ = single_300hPa_trough(parameter='hght')\nT = single_300hPa_trough(parameter='temp')\n\n# Lifting Trough\n# Z = lifting_300hPa_trough(parameter='hght')\n# T = lifting_300hPa_trough(parameter='temp')\n\n# Digging Trough\n# Z = digging_300hPa_trough(parameter='hght')\n# T = digging_300hPa_trough(parameter='temp')\n\nSet geographic parameters for analytic grid to then\n\nlats = np.linspace(35, 50, 101)\nlons = np.linspace(260, 290, 101)\nlon, lat = np.meshgrid(lons, lats)\n\n# Coriolis Parameter\nf = mpcalc.coriolis_parameter(lat * units.degrees)\n\n# Calculate Geostrophic Wind from Analytic Heights\ndx, dy = mpcalc.lat_lon_grid_deltas(lons, lats)\nugeo, vgeo = mpcalc.geostrophic_wind(Z*units.meter, dx, dy, latitude=lat * units.degrees)\n\n# Get the wind direction for each point\nwdir = mpcalc.wind_direction(ugeo, vgeo)\n\n# Compute the Gradient Wind via an approximation\ndydx = mpcalc.first_derivative(Z, delta=dx, axis=1)\nd2ydx2 = mpcalc.first_derivative(dydx, delta=dx, axis=1)\nR = ((1 + dydx.m**2)**(3. / 2.)) / d2ydx2.m\n\ngeo_mag = mpcalc.wind_speed(ugeo, vgeo)\ngrad_mag = geo_mag.m - (geo_mag.m**2) / (f.magnitude * R)\n\nugrad, vgrad = mpcalc.wind_components(grad_mag * units('m/s'), wdir)\n\n# Calculate Ageostrophic wind\nuageo = ugrad - ugeo\nvageo = vgrad - vgeo\n\n# Compute QVectors\nuqvect, vqvect = mpcalc.q_vector(ugeo, vgeo, T * units.degC, 500 * units.hPa, dx, dy)\n\n# Calculate divergence of the ageostrophic wind\ndiv = mpcalc.divergence(uageo, vageo, dx=dx, dy=dy)\n\n# Calculate Relative Vorticity Advection\nrelvor = mpcalc.vorticity(ugeo, vgeo, dx=dx, dy=dy)\nadv = mpcalc.advection(relvor, ugeo, vgeo, dx=dx, dy=dy)\n\nCreate figure containing Geopotential Heights, Temperature, Divergence\nof the Ageostrophic Wind, Relative Vorticity Advection (shaded),\ngeostrphic wind barbs, and Q-vectors.\n\nfig = plt.figure(figsize=(10, 10))\nax = plt.subplot(111)\n\n# Plot Geopotential Height Contours\ncs = ax.contour(lons, lats, Z, range(0, 12000, 120), colors='k')\nplt.clabel(cs, fmt='%d')\n\n# Plot Temperature Contours\ncs2 = ax.contour(lons, lats, T, range(-50, 50, 2), colors='r', linestyles='dashed')\nplt.clabel(cs2, fmt='%d')\n\n# Plot Divergence of Ageo Wind Contours\ncs3 = ax.contour(lons, lats, div*10**9, np.arange(-25, 26, 3), colors='grey',\n                 linestyles='dotted')\nplt.clabel(cs3, fmt='%d')\n\n# Plot Rel. Vor. Adv. colorfilled\ncf = ax.contourf(lons, lats, adv*10**9, np.arange(-20, 21, 1), cmap=plt.cm.bwr)\ncbar = plt.colorbar(cf, orientation='horizontal', pad=0.05, aspect=50)\ncbar.set_label('Rel. Vor. Adv.')\n\n# Plot Geostrophic Wind Barbs\nwind_slice = slice(5, None, 10)\nax.barbs(lons[wind_slice], lats[wind_slice],\n         ugeo[wind_slice, wind_slice].to('kt').m, vgeo[wind_slice, wind_slice].to('kt').m)\n\n# Plot Ageostrophic Wind Vectors\n# ageo_slice = slice(None, None, 10)\n# ax.quiver(lons[ageo_slice], lats[ageo_slice],\n#           uageo[ageo_slice, ageo_slice].m, vageo[ageo_slice, ageo_slice].m,\n#           color='blue', pivot='mid')\n\n# Plot QVectors\nqvec_slice = slice(None, None, 10)\nax.quiver(lons[qvec_slice], lats[qvec_slice],\n          uqvect[qvec_slice, qvec_slice].m, vqvect[qvec_slice, qvec_slice].m,\n          color='darkcyan', pivot='mid')\n\nplt.title('300-hPa Geo Heights (black), Q-Vector (dark cyan), Divergence (grey; dashed)')","type":"content","url":"/notebooks/synoptic/analytic-300hpa-trough","position":1},{"hierarchy":{"lvl1":"Differential Temperature Advection with NARR Data"},"type":"lvl1","url":"/notebooks/synoptic/differential-temperature-advection","position":0},{"hierarchy":{"lvl1":"Differential Temperature Advection with NARR Data"},"content":"By: Kevin Goebbert\n\nThis example creates a four-panel plot to illustrate the difference\nbetween single level temperature advection and a computed differential\ntemperature advection between two layers. This example makes use of NARR\noutput.\n\nimport cartopy.crs as ccrs\nimport cartopy.feature as cfeature\nimport matplotlib.gridspec as gridspec\nimport matplotlib.pyplot as plt\nimport metpy.calc as mpcalc\nfrom metpy.units import units\nimport numpy as np\nimport xarray as xr\n\n","type":"content","url":"/notebooks/synoptic/differential-temperature-advection","position":1},{"hierarchy":{"lvl1":"Differential Temperature Advection with NARR Data","lvl2":"Data Input"},"type":"lvl2","url":"/notebooks/synoptic/differential-temperature-advection#data-input","position":2},{"hierarchy":{"lvl1":"Differential Temperature Advection with NARR Data","lvl2":"Data Input"},"content":"Use Xarray to access GFS data from THREDDS resource and uses\nmetpy accessor to parse file to make it easy to pull data using\ncommon coordinate names (e.g., vertical) and attach units.\n\nds = xr.open_dataset('https://thredds.ucar.edu/thredds/dodsC/casestudies/'\n                     'python-gallery/NARR_19930313_1800.nc').metpy.parse_cf()\nds = ds.metpy.assign_latitude_longitude()\n\n# Get lat/lon data from file\nlats = ds.lat\nlons = ds.lon\n\n# Get 700-hPa data and smooth\nlevel = 700 * units.hPa\nhght_700 = mpcalc.smooth_n_point(ds['Geopotential_height_isobaric'].metpy.sel(\n    vertical=level).squeeze(), 9)\ntmpk_700 = mpcalc.smooth_n_point(ds['Temperature_isobaric'].metpy.sel(\n    vertical=level).squeeze(), 9)\nuwnd_700 = mpcalc.smooth_n_point(\n    ds['u-component_of_wind_isobaric'].metpy.sel(vertical=level).squeeze(), 9)\nvwnd_700 = mpcalc.smooth_n_point(\n    ds['v-component_of_wind_isobaric'].metpy.sel(vertical=level).squeeze(), 9)\n\n# Get 300-hPa data and\nlevel = 300 * units.hPa\nhght_300 = mpcalc.smooth_n_point(ds['Geopotential_height_isobaric'].metpy.sel(\n    vertical=level).squeeze(), 9)\ntmpk_300 = mpcalc.smooth_n_point(ds['Temperature_isobaric'].metpy.sel(\n    vertical=level).squeeze(), 9)\nuwnd_300 = mpcalc.smooth_n_point(\n    ds['u-component_of_wind_isobaric'].metpy.sel(vertical=level).squeeze(), 9)\nvwnd_300 = mpcalc.smooth_n_point(\n    ds['v-component_of_wind_isobaric'].metpy.sel(vertical=level).squeeze(), 9)\n\n# Convert Temperatures to degC\ntmpc_700 = tmpk_700.metpy.convert_units('degC')\ntmpc_300 = tmpk_300.metpy.convert_units('degC')\n\n# Get time in a nice datetime object format\nvtime = ds.time.values.astype('datetime64[ms]').astype('O')[0]\n\n","type":"content","url":"/notebooks/synoptic/differential-temperature-advection#data-input","position":3},{"hierarchy":{"lvl1":"Differential Temperature Advection with NARR Data","lvl2":"Differential Temperature Advection Calculation"},"type":"lvl2","url":"/notebooks/synoptic/differential-temperature-advection#differential-temperature-advection-calculation","position":4},{"hierarchy":{"lvl1":"Differential Temperature Advection with NARR Data","lvl2":"Differential Temperature Advection Calculation"},"content":"Use MetPy advection funtion to calculate temperature advection at 700\nand 300 hPa, then manually compute the differential between those two\nlayers. The differential temperature advection is then valid at 500 hPa\n(due to centered differencing) and is the same level that height changes\ndue to absolute vorticity advection is commonly assessed.\n\n# Use MetPy advection function to calculate temperature advection at two levels\ntadv_700 = mpcalc.advection(tmpk_700, uwnd_700, vwnd_700)\ntadv_300 = mpcalc.advection(tmpk_300, uwnd_300, vwnd_300)\n\n# Centered finite difference to calculate differential temperature advection\ndiff_tadv = ((tadv_700.data - tadv_300.data)/(400 * units.hPa)).to_base_units()\n\n","type":"content","url":"/notebooks/synoptic/differential-temperature-advection#differential-temperature-advection-calculation","position":5},{"hierarchy":{"lvl1":"Differential Temperature Advection with NARR Data","lvl2":"Make Four Panel Plot"},"type":"lvl2","url":"/notebooks/synoptic/differential-temperature-advection#make-four-panel-plot","position":6},{"hierarchy":{"lvl1":"Differential Temperature Advection with NARR Data","lvl2":"Make Four Panel Plot"},"content":"A four panel plot is produced to illustrate the temperature fields at\ntwo levels (700 and 300 hPa), which are common fields to be plotted.\nThen a panel containing the evaluated temperature advection at 700 hPa\nand differential temperature advection between 700 and 300 hPa. Of\nmeteorological significance is the difference between these two\nadvection plots. For the QG Height Tendency equation, the forcing term\nis proportional to the differential temperature advection, which paints\na slightly different picture than just the 700-hPa temperature advection\nalone.\n\nTo create the four panel plot it takes a bit of code at this point. The\nfollowing code is segmented into Upper-left, Lower-left, Upper-right,\nLower-right panels using matplotlib’s gridspec to help with spacing.\n\n# Set up plot crs (mapcrs) and the data crs, will need to\n# transform all variables\nmapcrs = ccrs.LambertConformal(central_longitude=-100,\n                               central_latitude=35,\n                               standard_parallels=(30, 60))\ndatacrs = ccrs.PlateCarree()\n\n# Set some common contour interval levels\nclevs_700_tmpc = np.arange(-40, 41, 2)\nclevs_700_hght = np.arange(0, 8000, 30)\nclevs_300_hght = np.arange(0, 10000, 120)\n\n# Create slice to reduce number of wind barbs at plot time\nwind_slice = (slice(None, None, 10), slice(None, None, 10))\n\n# Start figure\nfig = plt.figure(1, figsize=(22, 15))\n\n# Use gridspec to help size elements of plot; small top plot\n# and big bottom plot\ngs = gridspec.GridSpec(nrows=2, ncols=2, height_ratios=[1, 1],\n                       hspace=0.03, wspace=0.03)\n\n\n# Upper-left panel (700-hPa TMPC)\nax1 = plt.subplot(gs[0, 0], projection=mapcrs)\nax1.set_extent([-130, -72, 25, 49], ccrs.PlateCarree())\nax1.add_feature(cfeature.COASTLINE.with_scale('50m'))\nax1.add_feature(cfeature.STATES.with_scale('50m'))\n\ncf = ax1.contourf(lons, lats, tmpc_700, clevs_700_tmpc,\n                  cmap=plt.cm.coolwarm, transform=datacrs)\ncb = plt.colorbar(cf, orientation='horizontal', pad=0, aspect=50)\ncb.set_label(r'$^{\\circ}$C')\n\ncsf = ax1.contour(lons, lats, tmpc_700, clevs_700_tmpc, colors='grey',\n                  linestyles='dashed', transform=datacrs)\nplt.clabel(csf, fmt='%d')\n\ncs = ax1.contour(lons, lats, hght_700, clevs_700_hght, colors='black',\n                 transform=datacrs)\nplt.clabel(cs, fmt='%d')\n\nax1.barbs(lons[wind_slice].values, lats[wind_slice].values,\n          uwnd_700.metpy.convert_units('kt')[wind_slice].values,\n          vwnd_700[wind_slice].metpy.convert_units('kt').values,\n          pivot='middle', color='black', transform=datacrs)\n\nplt.title('700-hPa NARR HGHT (m), TMPC, and Wind (kt)', loc='left')\nplt.title(f'Valid: {vtime}', loc='right')\n\n\n# Lower-left panel (300-hPa TMPC)\nax2 = plt.subplot(gs[1, 0], projection=mapcrs)\nax2.set_extent([-130, -72, 25, 49], ccrs.PlateCarree())\nax2.add_feature(cfeature.COASTLINE.with_scale('50m'))\nax2.add_feature(cfeature.STATES.with_scale('50m'))\n\ncf = ax2.contourf(lons, lats, tmpc_300, range(-60, -24, 2),\n                  cmap=plt.cm.BuPu_r, transform=datacrs)\ncb = plt.colorbar(cf, orientation='horizontal', pad=0, aspect=50)\ncb.set_label(r'$^{\\circ}$C')\n\ncsf = ax2.contour(lons, lats, tmpc_300, range(-60, 0, 2),\n                  colors='grey', linestyles='dashed', transform=datacrs)\nplt.clabel(csf, fmt='%d')\n\ncs = ax2.contour(lons, lats, hght_300, clevs_300_hght, colors='black',\n                 transform=datacrs)\nplt.clabel(cs, fmt='%d')\n\nax2.barbs(lons[wind_slice].values, lats[wind_slice].values,\n          uwnd_300.metpy.convert_units('kt')[wind_slice].values,\n          vwnd_300[wind_slice].metpy.convert_units('kt').values,\n          pivot='middle', color='black', transform=datacrs)\n\nplt.title('300-hPa NARR HGHT (m), TMPC, and Wind (kt)', loc='left')\nplt.title(f'Valid: {vtime}', loc='right')\n\n\n# Upper-right panel (700-hPa TMPC Adv)\nax3 = plt.subplot(gs[0, 1], projection=mapcrs)\nax3.set_extent([-130, -72, 25, 49], ccrs.PlateCarree())\nax3.add_feature(cfeature.COASTLINE.with_scale('50m'))\nax3.add_feature(cfeature.STATES.with_scale('50m'))\n\ncf = ax3.contourf(lons, lats, tadv_700*3600, range(-8, 9, 1),\n                  cmap=plt.cm.coolwarm, transform=datacrs)\ncb = plt.colorbar(cf, orientation='horizontal', pad=0, aspect=50)\ncb.set_label(r'TMPC ADV ($^{\\circ}$C h$^{-1}$)')\n\ncsf = ax3.contour(lons, lats, tmpc_700, clevs_700_tmpc, colors='grey',\n                  linestyles='dashed', transform=datacrs)\nplt.clabel(csf, fmt='%d')\n\ncs = ax3.contour(lons, lats, hght_700, clevs_700_hght, colors='black',\n                 transform=datacrs)\nplt.clabel(cs, fmt='%d')\n\nax3.barbs(lons[wind_slice].values, lats[wind_slice].values,\n          uwnd_700.metpy.convert_units('kt')[wind_slice].values,\n          vwnd_700[wind_slice].metpy.convert_units('kt').values,\n          pivot='middle', color='black', transform=datacrs)\n\nplt.title('700-hPa NARR HGHT (m), TMP ADV (C/h), and Wind (kt)', loc='left')\nplt.title(f'Valid: {vtime}', loc='right')\n\n\n# Lower-right panel (diff TMPC)\nax4 = plt.subplot(gs[1, 1], projection=mapcrs)\nax4.set_extent([-130, -72, 25, 49], ccrs.PlateCarree())\nax4.add_feature(cfeature.COASTLINE.with_scale('50m'))\nax4.add_feature(cfeature.STATES.with_scale('50m'))\n\ncf = ax4.contourf(lons, lats, diff_tadv*1e9, clevs_700_tmpc,\n                  cmap=plt.cm.coolwarm, extend='both', transform=datacrs)\ncb = plt.colorbar(cf, orientation='horizontal', pad=0, aspect=50,\n                  extendrect=True)\ncb.set_label(r'dTMPC ($10^9$ $^{\\circ}$C s$^{-1}$ Pa$^{-1}$)')\n\ncsf = ax4.contour(lons, lats, tmpc_700, clevs_700_tmpc, colors='grey',\n                  linestyles='dashed', transform=datacrs)\nplt.clabel(csf, fmt='%d')\n\ncs = ax4.contour(lons, lats, hght_700, clevs_700_hght, colors='black',\n                 transform=datacrs)\nplt.clabel(cs, fmt='%d')\n\nax4.barbs(lons[wind_slice].values, lats[wind_slice].values,\n          uwnd_700.metpy.convert_units('kt')[wind_slice].values,\n          vwnd_700[wind_slice].metpy.convert_units('kt').values,\n          pivot='middle', color='black', transform=datacrs)\n\nplt.title('700-hPa NARR HGHT (m), Diff. TMP ADV (C/s/Pa), and Wind (kt)', loc='left')\nplt.title(f'Valid: {vtime}', loc='right')","type":"content","url":"/notebooks/synoptic/differential-temperature-advection#make-four-panel-plot","position":7},{"hierarchy":{"lvl1":"Geostrophic Wind and Other Calcuations"},"type":"lvl1","url":"/notebooks/synoptic/geostrophic-wind-and-few-more","position":0},{"hierarchy":{"lvl1":"Geostrophic Wind and Other Calcuations"},"content":"Demonstrate a variety of calculations in MetPy.\n\nimport metpy.calc as mpcalc\nimport xarray as xr\nimport numpy as np\nfrom metpy.calc import geostrophic_wind\nfrom metpy.calc import q_vector\nfrom metpy.units import units\nimport matplotlib.pyplot as plt\nimport cartopy.crs as ccrs\nimport cartopy.feature as cfeature\nfrom scipy.ndimage.filters import gaussian_filter\n\n## opening NetCDF file using xarray \n\nds = xr.open_dataset(\"../convective/NETCDF_FILE.nc\", decode_times=True)\n\nds\n\n#### making a function to slice the xarray dataset according to our need.\ndef slicer (data,lat1, lat2, lon1, lon2, time1,time2) :\n    sliced_data = data.sel(lat =slice(lat1, lat2), lon = slice(lon1, lon2),time = slice(time1, time2))\n    return sliced_data\n\n#slicing the data for CONUS only\n\nnew_data = slicer(ds,23.5,50.5,-125.5,-66.5, ds.time[0], ds.time[0])\n\nnew_data\n\n###extracting temperature, pressure, and geopotential from the dataset\ngph = new_data.H\np =new_data.lev\nT = new_data.T\n\ngph\n\nU,V = geostrophic_wind(gph)\n\nnp.shape(U)\n\ndataproj = ccrs. PlateCarree ()\n# # Plot projection\n# # The look you want for the view.\nplotproj = ccrs. PlateCarree ()\nfig=plt.figure(1, figsize=(15.,12.))\n\nax=plt.subplot(111,projection=plotproj)\n\nax.add_feature(cfeature.COASTLINE, linewidth=0.5)\nax.add_feature(cfeature.STATES, linewidth=0.5)\nplt.title(\"Geostrophic Wind Calculated Using Metpy\",size = 30)\nplt.quiver (new_data.lon, new_data.lat, U[0,12,:,:],V[0,12,:,:],minlength = 0.5,units='width')\n# plt.colorbar (orientation = \"horizontal\", pad=0.01).ax.tick_params(labelsize=20)\nplt. show ()\n\nqx, qy = q_vector(U,V,T,p)\n\ndataproj = ccrs. PlateCarree ()\n# # Plot projection\n# # The look you want for the view.\nplotproj = ccrs. PlateCarree ()\nfig=plt.figure(1, figsize=(15.,12.))\n\nax=plt.subplot(111,projection=plotproj)\n\nax.add_feature(cfeature.COASTLINE, linewidth=0.5)\nax.add_feature(cfeature.STATES, linewidth=0.5)\nplt.title(\"Q-vector Calculated Using Metpy\",size = 30)\n\nplt.contour(new_data.lon, new_data.lat,gaussian_filter(gph[0,12,:,:],1), colors = \"black\")\n# plt.contourf(new_data.lon, new_data.lat, new_data.OMEGA[0,12,:,:],levels =np.arange(-2,2,0.2),cmap = \"RdBu\", transform=dataproj,extend = \"both\" )\nplt.colorbar (orientation = \"horizontal\", pad=0.01).ax.tick_params(labelsize=20)\n# plt.colorbar (orientation = \"horizontal\", pad=0.01).ax.tick_params(labelsize=20)\nplt.quiver (new_data.lon, new_data.lat, qx[0,12,:,:],gaussian_filter(qy[0,12,:,:],0.7), color='blue',pivot='mid', \n          scale=1e-11, scale_units='inches',\n          transform=dataproj)\n\n# gaussian_filter(data, sigma)\nplt. show ()","type":"content","url":"/notebooks/synoptic/geostrophic-wind-and-few-more","position":1},{"hierarchy":{"lvl1":"Isentropic Analysis"},"type":"lvl1","url":"/notebooks/synoptic/isentropic-interpolation","position":0},{"hierarchy":{"lvl1":"Isentropic Analysis"},"content":"The MetPy function metpy.calc.isentropic_interpolation allows for isentropic analysis from\nmodel analysis data in isobaric coordinates.\n\nfrom datetime import datetime, timedelta\n\nimport cartopy.crs as ccrs\nimport cartopy.feature as cfeature\nimport matplotlib.pyplot as plt\nimport metpy.calc as mpcalc\nfrom metpy.units import units\nimport numpy as np\nfrom siphon.catalog import TDSCatalog\nfrom xarray.backends import NetCDF4DataStore\nimport xarray as xr\n\nGetting the data\n\nIn this example, the latest GFS forecasts data from the National Centers for\nEnvironmental Information (\n\nhttps://​www​.ncei​.noaa​.gov) will be used, courtesy of the\nUniveristy Corporation for Atmospheric Research Thredds Data Server.\n\n# Latest GFS Dataset\ncat = TDSCatalog('http://thredds.ucar.edu/thredds/catalog/grib/'\n                 'NCEP/GFS/Global_0p5deg/catalog.xml')\nncss = cat.latest.subset()\n\n# Find the start of the model run and define time range\nstart_time = ncss.metadata.time_span['begin']\nstart = datetime.strptime(start_time, '%Y-%m-%dT%H:%M:%Sz')\nend = start + timedelta(hours=9)\n\n# Query for Latest GFS Run\ngfsdata = ncss.query().time_range(start, end).accept('netcdf4')\n\ngfsdata.variables('Temperature_isobaric',\n                  'u-component_of_wind_isobaric',\n                  'v-component_of_wind_isobaric',\n                  'Relative_humidity_isobaric').add_lonlat()\n\n# Set the lat/lon box for the data you want to pull in.\n# lonlat_box(north_lat,south_lat,east_lon,west_lon)\ngfsdata.lonlat_box(-150, -50, 15, 65)\n\n# Actually getting the data\ndata = ncss.get_data(gfsdata)\n\n# Make into an xarray Dataset object\nds = xr.open_dataset(NetCDF4DataStore(data)).metpy.parse_cf()\n\ndlev_hght = ds.Temperature_isobaric.dims[1]\ndlev_uwnd = ds['u-component_of_wind_isobaric'].dims[1]\nlat = ds.latitude\nlon = ds.longitude\n\nlev_hght = ds[dlev_hght]\nlev_uwnd = ds[dlev_uwnd]\n\n# Due to a different number of vertical levels find where they are common\n_, _, common_ind = np.intersect1d(lev_uwnd, lev_hght, return_indices=True)\n\ncommon_levels = lev_hght[common_ind].metpy.unit_array\ntimes = ds.Temperature_isobaric.metpy.time\nvtimes = times.values.astype('datetime64[ms]').astype('O')\ntemps = ds.Temperature_isobaric.metpy.unit_array\nuwnd = ds['u-component_of_wind_isobaric'].metpy.unit_array\nvwnd = ds['v-component_of_wind_isobaric'].metpy.unit_array\nrelh = ds.Relative_humidity_isobaric.metpy.unit_array\n\nTo properly interpolate to isentropic coordinates, the function must know the desired output\nisentropic levels. An array with these levels will be created below.\n\nisentlevs = np.arange(310, 316, 5) * units.kelvin\n\nConversion to Isentropic Coordinates\n\nOnce model data in isobaric coordinates has been pulled and the desired isentropic levels\ncreated, the conversion to isentropic coordinates can begin. Data will be passed to the\nfunction as below. The function requires that isentropic levels, isobaric levels, and\ntemperature be input. Any additional inputs (in this case relative humidity, u, and v wind\ncomponents) will be linearly interpolated to isentropic space.\n\nisent_anal = mpcalc.isentropic_interpolation(isentlevs,\n                                             common_levels,\n                                             temps[:, common_ind, :, :],\n                                             relh,\n                                             uwnd,\n                                             vwnd,\n                                             vertical_dim=1)\n\nThe output is a list, so now we will separate the variables to different names before\nplotting.\n\nisentprs, isentrh, isentu, isentv = isent_anal\n\nA quick look at the shape of these variables will show that the data is now in isentropic\ncoordinates, with the number of vertical levels as specified above.\n\nprint(isentprs.shape)\nprint(isentrh.shape)\nprint(isentu.shape)\nprint(isentv.shape)\n\nPlotting the Isentropic Analysis\n\nSet up our projection\n\ncrs = ccrs.LambertConformal(central_longitude=-100.0, central_latitude=45.0)\n\n# Set up our array of latitude and longitude values and transform to\n# the desired projection.\nclons, clats = np.meshgrid(lon, lat)\n\n# Get data to plot state and province boundaries\nstates_provinces = cfeature.NaturalEarthFeature(\n    category='cultural',\n    name='admin_1_states_provinces_lakes',\n    scale='50m',\n    facecolor='none')\n\n# Choose Isentropic Level index value\nlevel = 0 # [310, 315]\n\n# Choose forecast hour index value\nFH = 0 # [0, 3, 6, 9]\n\n# Start Figure\nfig = plt.figure(1, figsize=(14., 12.))\nax = plt.subplot(111, projection=crs)\n\n# Set plot extent\nax.set_extent((-121., -74., 25., 50.), crs=ccrs.PlateCarree())\nax.coastlines('50m', edgecolor='black', linewidth=0.75)\nax.add_feature(states_provinces, edgecolor='black', linewidth=0.5)\n\n# Plot the 300K surface\nclevisent = np.arange(0, 1000, 25)\ncs = ax.contour(clons, clats,\n                mpcalc.smooth_n_point(isentprs[FH, level, :, :], 9, 4),\n                clevisent,\n                transform=ccrs.PlateCarree(),\n                colors='k', linewidths=1.5, linestyles='solid')\nplt.clabel(cs, fontsize=10, inline=1, inline_spacing=7,\n           fmt='%i', rightside_up=True, use_clabeltext=True)\n\ncf = ax.contourf(clons, clats,\n                 mpcalc.smooth_n_point(isentrh[FH, level, :, :], 9, 4),\n                 np.arange(50, 101, 1),\n                 transform=ccrs.PlateCarree(),\n                 cmap=plt.cm.YlGn)\nplt.colorbar(cf, orientation='horizontal', aspect=65, pad=0, extendrect='True')\n\nwind_slice = (FH, level, slice(None, None, 5), slice(None, None, 5))\nax.barbs(clons[wind_slice[2:]], clats[wind_slice[2:]],\n         isentu[wind_slice].m, isentv[wind_slice].m, length=6,\n         transform=ccrs.PlateCarree())\n\n# Make some titles\nplt.title(f'{isentlevs[level].m:.0f} K Isentropic Level', loc='left')\nplt.title(f'VALID: {vtimes[FH]} UTC', loc='right')","type":"content","url":"/notebooks/synoptic/isentropic-interpolation","position":1},{"hierarchy":{"lvl1":"Baroclinic Potential Vorticity Analysis, Divergence, and Winds"},"type":"lvl1","url":"/notebooks/synoptic/pv-baroclinic-isobaric","position":0},{"hierarchy":{"lvl1":"Baroclinic Potential Vorticity Analysis, Divergence, and Winds"},"content":"Classic baroclinic potential vorticity plot at 250 hPa using GFS\nanalysis file.\n\nThis example uses example data from the GFS analysis for 12 UTC 31\nOctober 2016 and uses xarray as the main read source with using MetPy to\ncalculate the baroclinic potential vorticity, divergence and wind speed\nwith geographic plotting using Cartopy for a CONUS view of the 250-hPa\nsurface with divergence and wind barbs.\n\nBy: Kevin Goebbert\n\nimport cartopy.crs as ccrs\nimport cartopy.feature as cfeature\nimport matplotlib.pyplot as plt\nimport metpy.calc as mpcalc\nfrom metpy.units import units\nimport numpy as np\nimport xarray as xr\n\nThe following code reads the example data using the xarray open_dataset\nfunction and prints the coordinate values that are associated with the\nvarious variables contained within the file.\n\nThis code uses the metpy accessor to parse file to make it easy to pull\ndata using common coordinate names (e.g., vertical) and attach units.\n\nds = xr.open_dataset('https://thredds.ucar.edu/thredds/dodsC/casestudies'\n                     '/python-gallery/GFS_20101026_1200.nc').metpy.parse_cf()\n\n","type":"content","url":"/notebooks/synoptic/pv-baroclinic-isobaric","position":1},{"hierarchy":{"lvl1":"Baroclinic Potential Vorticity Analysis, Divergence, and Winds","lvl2":"Data Retrieval"},"type":"lvl2","url":"/notebooks/synoptic/pv-baroclinic-isobaric#data-retrieval","position":2},{"hierarchy":{"lvl1":"Baroclinic Potential Vorticity Analysis, Divergence, and Winds","lvl2":"Data Retrieval"},"content":"This code retrieves the necessary data from the file and completes some\nsmoothing of the temperature, and wind fields using the MetPy function\nsmooth_n_point. A nicely formated valid time (vtime) variable is also\ncreated.\n\n# Set subset slice for the geographic extent of data to limit download\nlon_slice = slice(200, 350)\nlat_slice = slice(85, 10)\n\n# Grab lat/lon values (GFS will be 1D)\nlats = ds.lat.sel(lat=lat_slice).values\nlons = ds.lon.sel(lon=lon_slice).values\n\n\n# Grab the pressure levels and select the data to be imported\n# Need all pressure levels for Temperatures, U and V Wind,\n# and Rel. Humidity\n# Smooth with the gaussian filter from scipy\npres = ds.Temperature_isobaric.metpy.vertical\n\ntmpk_var = ds['Temperature_isobaric'].metpy.sel(\n    lat=lat_slice, lon=lon_slice).squeeze()\ntmpk = mpcalc.smooth_n_point(tmpk_var, 9, 2)\nthta = mpcalc.potential_temperature(pres, tmpk)\n\nuwnd_var = ds['u-component_of_wind_isobaric'].metpy.sel(\n    lat=lat_slice, lon=lon_slice).squeeze()\nvwnd_var = ds['v-component_of_wind_isobaric'].metpy.sel(\n    lat=lat_slice, lon=lon_slice).squeeze()\nuwnd = mpcalc.smooth_n_point(uwnd_var, 9, 2)\nvwnd = mpcalc.smooth_n_point(vwnd_var, 9, 2)\n\n# Create a clean datetime object for plotting based on time of\n# Geopotential heights\nvtime = ds.time.data[0].astype('datetime64[ms]').astype('O')\n\nUse MetPy to compute the baroclinic potential vorticity on all isobaric\nlevels and other variables\n\n# Comput the PV on all isobaric surfaces\npv = mpcalc.potential_vorticity_baroclinic(thta, pres, uwnd, vwnd)\n\n# Use MetPy to compute the divergence on the pressure surfaces\ndiv = mpcalc.divergence(uwnd, vwnd)\n\n# Select the 250-hPa surface\npv_250 = pv.metpy.sel(vertical=250*units.hPa)\ndiv_250 = div.metpy.sel(vertical=250*units.hPa)\nuwnd_250 = uwnd.metpy.sel(vertical=250*units.hPa)\nvwnd_250 = vwnd.metpy.sel(vertical=250*units.hPa)\n\n","type":"content","url":"/notebooks/synoptic/pv-baroclinic-isobaric#data-retrieval","position":3},{"hierarchy":{"lvl1":"Baroclinic Potential Vorticity Analysis, Divergence, and Winds","lvl2":"Map Creation"},"type":"lvl2","url":"/notebooks/synoptic/pv-baroclinic-isobaric#map-creation","position":4},{"hierarchy":{"lvl1":"Baroclinic Potential Vorticity Analysis, Divergence, and Winds","lvl2":"Map Creation"},"content":"This next set of code creates the plot and draws contours on a Lambert\nConformal map centered on -100 E longitude. The main view is over the\nCONUS with isobaric PV map with PV contoured every 1 PVU and divergence\ncolorshaded.\n\n# Set up the projection that will be used for plotting\nmapcrs = ccrs.LambertConformal(central_longitude=-100,\n                               central_latitude=35,\n                               standard_parallels=(30, 60))\n\n# Set up the projection of the data;\n# if lat/lon then PlateCarree is what you want\ndatacrs = ccrs.PlateCarree()\n\n# Start the figure and create plot axes with proper projection\nfig = plt.figure(1, figsize=(14, 12))\nax = plt.subplot(111, projection=mapcrs)\nax.set_extent([-130, -72, 20, 55], ccrs.PlateCarree())\n\n# Add geopolitical boundaries for map reference\nax.add_feature(cfeature.COASTLINE.with_scale('50m'))\nax.add_feature(cfeature.STATES.with_scale('50m'))\n\n# Plot the contours of PV at 250 hPa, scaling 10^6 every 1 PVU\nclevs_pv = np.arange(0, 25, 1)\ncs1 = ax.contour(lons, lats, pv_250*1e6, clevs_pv, colors='black',\n                 transform=datacrs)\nplt.clabel(cs1, fmt='%d', fontsize='large')\n\n# Plot the colorfill of divergence, scaled 10^5 every 1 s^1\nclevs_div = np.arange(-15, 16, 1)\ncs1 = ax.contourf(lons, lats, div_250*1e5, clevs_div, cmap=plt.cm.PuOr,\n                  extend='both', transform=datacrs)\nplt.colorbar(cs1, orientation='horizontal', pad=0, aspect=50, extendrect=True)\n\n# Plot the wind barbs at 250 hPa\nwind_slice = slice(None, None, 6)\nax.barbs(lons[wind_slice], lats[wind_slice],\n         uwnd_250[wind_slice, wind_slice].metpy.convert_units('kt').values,\n         vwnd_250[wind_slice, wind_slice].metpy.convert_units('kt').values,\n         pivot='middle', color='black', length=6.5, transform=datacrs)\n\n# Plot some titles to tell people what is on the map\nplt.title('250-hPa GFS PV (PVU), Divergence ($10^5$ s$^{-1}$),'\n          ' and Wind Barbs (kt)', loc='left')\nplt.title(f'Valid Time: {vtime}', loc='right')","type":"content","url":"/notebooks/synoptic/pv-baroclinic-isobaric#map-creation","position":5},{"hierarchy":{"lvl1":"DIFAX Replication"},"type":"lvl1","url":"/notebooks/synoptic/upperair-obs","position":0},{"hierarchy":{"lvl1":"DIFAX Replication"},"content":"This example replicates the traditional DIFAX images for upper-level\nobservations.\n\nBy: Kevin Goebbert\n\nObservation data comes from Iowa State Archive, accessed through the\nSiphon package. Contour data comes from the GFS 0.5 degree analysis.\nClassic upper-level data of Geopotential Height and Temperature are\nplotted.\n\nimport urllib.request\n\nfrom datetime import datetime, timedelta, UTC\n\nimport cartopy.crs as ccrs\nimport cartopy.feature as cfeature\nimport matplotlib.pyplot as plt\nfrom matplotlib.ticker import FixedLocator\nimport metpy.calc as mpcalc\nimport numpy as np\nimport xarray as xr\n\nfrom metpy.io import add_station_lat_lon\nfrom metpy.calc import find_peaks\nfrom metpy.plots import scattertext, StationPlot\nfrom metpy.units import units\nfrom siphon.simplewebservice.iastate import IAStateUpperAir\n\n","type":"content","url":"/notebooks/synoptic/upperair-obs","position":1},{"hierarchy":{"lvl1":"DIFAX Replication","lvl2":"Observation Data"},"type":"lvl2","url":"/notebooks/synoptic/upperair-obs#observation-data","position":2},{"hierarchy":{"lvl1":"DIFAX Replication","lvl2":"Observation Data"},"content":"Set a date and time for upper-air observations (should only be 00 or 12\nUTC for the hour).\n\nRequest all data from Iowa State using the Siphon package. The result is\na pandas DataFrame containing all of the sounding data from all\navailable stations.\n\n# Set date for desired UPA data\ntoday = datetime.now(UTC)\n\n# Go back one day to ensure data availability\ndate = datetime(today.year, today.month, today.day, 0) - timedelta(days=1)\n\n# Request data using Siphon request for data from Iowa State Archive\ndata = IAStateUpperAir.request_all_data(date)\n\n","type":"content","url":"/notebooks/synoptic/upperair-obs#observation-data","position":3},{"hierarchy":{"lvl1":"DIFAX Replication","lvl2":"Subset Observational Data"},"type":"lvl2","url":"/notebooks/synoptic/upperair-obs#subset-observational-data","position":4},{"hierarchy":{"lvl1":"DIFAX Replication","lvl2":"Subset Observational Data"},"content":"From the request above will give all levels from all radisonde sites\navailable through the service. For plotting a pressure surface map there\nis only need to have the data from that level. Below the data is subset\nand a few parameters set based on the level chosen. Additionally, the\nstation information is obtained and latitude and longitude data is added\nto the DataFrame.\n\nlevel = 500\n\nif (level == 925) | (level == 850) | (level == 700):\n    cint = 30\n    def hght_format(v): return format(v, '.0f')[1:]\nelif level == 500:\n    cint = 60\n    def hght_format(v): return format(v, '.0f')[:3]\nelif level == 300:\n    cint = 120\n    def hght_format(v): return format(v, '.0f')[:3]\nelif level < 300:\n    cint = 120\n    def hght_format(v): return format(v, '.0f')[1:4]\n\n# Create subset of all data for a given level\ndata_subset = data.pressure == level\ndf = data[data_subset]\n\n# Get station lat/lon from look-up file; add to Dataframe\ndf = add_station_lat_lon(df)\n\n","type":"content","url":"/notebooks/synoptic/upperair-obs#subset-observational-data","position":5},{"hierarchy":{"lvl1":"DIFAX Replication","lvl2":"Gridded Data"},"type":"lvl2","url":"/notebooks/synoptic/upperair-obs#gridded-data","position":6},{"hierarchy":{"lvl1":"DIFAX Replication","lvl2":"Gridded Data"},"content":"Obtain GFS gridded output for contour plotting. Specifically,\ngeopotential height and temperature data for the given level and subset\nfor over North America. Data are smoothed for aesthetic reasons.\n\n# Get GFS data and subset to North America for Geopotential Height and Temperature\nds = xr.open_dataset('https://thredds.ucar.edu/thredds/dodsC/grib/NCEP/GFS/Global_0p5deg_ana/'\n                     'GFS_Global_0p5deg_ana_{0:%Y%m%d}_{0:%H}00.grib2'.format(\n                         date)).metpy.parse_cf()\n\n# Geopotential height\nhght = ds.Geopotential_height_isobaric.metpy.sel(\n    vertical=level*units.hPa, time=date, lat=slice(70, 15), lon=slice(360-145, 360-50))\n\n# Temperature\ntmpk = ds.Temperature_isobaric.metpy.sel(\n    vertical=level*units.hPa, time=date, lat=slice(70, 15), lon=slice(360-145, 360-50))\n\nNew in MetPy v1.7, we can use \n\nmetpy​.calc​.find​_peaks to find local maxima and minima from our data. We can specify a higher IQR Ratio to see fewer, stronger peaks. Then we can smooth our data for seeing larger-scale patterns in the final contours.\n\n# Find the location of local max/min geopotential heights\nH_y, H_x = find_peaks(hght, iqr_ratio=4)\nL_y, L_x = find_peaks(hght, maxima=False, iqr_ratio=4)\n\n# Smooth our fields for the chart\nsmooth_hght = mpcalc.smooth_n_point(hght, 9, 10)\nsmooth_tmpc = (mpcalc.smooth_n_point(tmpk, 9, 10)).metpy.convert_units('degC')\n\n","type":"content","url":"/notebooks/synoptic/upperair-obs#gridded-data","position":7},{"hierarchy":{"lvl1":"DIFAX Replication","lvl2":"Create DIFAX Replication"},"type":"lvl2","url":"/notebooks/synoptic/upperair-obs#create-difax-replication","position":8},{"hierarchy":{"lvl1":"DIFAX Replication","lvl2":"Create DIFAX Replication"},"content":"Plot the observational data and contours on a Lambert Conformal map and\nadd features that resemble the historic DIFAX maps.\n\n# Set up map coordinate reference system\nmapcrs = ccrs.LambertConformal(\n    central_latitude=45, central_longitude=-100, standard_parallels=(30, 60))\n\n# Set up station locations for plotting observations\npoint_locs = mapcrs.transform_points(\n    ccrs.PlateCarree(), df['longitude'].values, df['latitude'].values)\n\n# Start figure and set graphics extent\nfig = plt.figure(1, figsize=(17, 15))\nax = plt.subplot(111, projection=mapcrs)\nax.set_extent([-125, -70, 20, 55])\n\n# Add map features for geographic reference\nax.add_feature(cfeature.COASTLINE.with_scale('50m'), edgecolor='grey')\nax.add_feature(cfeature.LAND.with_scale('50m'), facecolor='white')\nax.add_feature(cfeature.STATES.with_scale('50m'), edgecolor='grey')\n\n# Plot plus signs every degree lat/lon\nplus_lat = []\nplus_lon = []\nother_lat = []\nother_lon = []\n\nfor x in hght.lon.values[::2]:\n    for y in hght.lat.values[::2]:\n        if (x % 5 == 0) | (y % 5 == 0):\n            plus_lon.append(x)\n            plus_lat.append(y)\n        else:\n            other_lon.append(x)\n            other_lat.append(y)\nax.scatter(other_lon, other_lat, s=2, marker='o',\n           transform=ccrs.PlateCarree(), color='lightgrey', zorder=-1)\nax.scatter(plus_lon, plus_lat, s=30, marker='+', transform=ccrs.PlateCarree(),\n           color='lightgrey')\n\n# Add gridlines for every 5 degree lat/lon\nax.gridlines(linestyle='solid', ylocs=range(15, 71, 5), xlocs=range(-150, -49, 5))\n\n# Start the station plot by specifying the axes to draw on, as well as the\n# lon/lat of the stations (with transform). We also the fontsize to 10 pt.\nstationplot = StationPlot(ax, df['longitude'].values, df['latitude'].values, clip_on=True,\n                          transform=ccrs.PlateCarree(), fontsize=10)\n\n# Plot the temperature and dew point to the upper and lower left, respectively, of\n# the center point.\nstationplot.plot_parameter('NW', df['temperature'], color='black')\nstationplot.plot_parameter('SW', df['dewpoint'], color='black')\n\n# A more complex example uses a custom formatter to control how the geopotential height\n# values are plotted. This is set in an earlier if-statement to work appropriate for\n# different levels.\nstationplot.plot_parameter('NE', df['height'], formatter=hght_format)\n\n# Add wind barbs\nstationplot.plot_barb(df['u_wind'], df['v_wind'], length=7, pivot='tip')\n\n# Plot Solid Contours of Geopotential Height\ncs = ax.contour(hght.lon, hght.lat, smooth_hght,\n                range(0, 20000, cint), colors='black', transform=ccrs.PlateCarree())\nclabels = plt.clabel(cs, fmt='%d', colors='white', inline_spacing=5, use_clabeltext=True)\n\n# Contour labels with black boxes and white text\nfor t in cs.labelTexts:\n    t.set_bbox({'facecolor': 'black', 'pad': 4})\n    t.set_fontweight('heavy')\n\n# Plot Dashed Contours of Temperature\ncs2 = ax.contour(hght.lon, hght.lat, smooth_tmpc, range(-60, 51, 5),\n                 colors='black', transform=ccrs.PlateCarree())\nclabels = plt.clabel(cs2, fmt='%d', colors='black', inline_spacing=5, use_clabeltext=True)\n\n# Set longer dashes than default\ncs2.set(dashes=(0, (5.0, 3.0)))\n\n# Contour labels with black boxes and white text\nfor t in cs.labelTexts:\n    t.set_bbox({'facecolor': 'black', 'pad': 4})\n    t.set_fontweight('heavy')\n\n# Plot filled circles for Radiosonde Obs\nax.scatter(df['longitude'].values, df['latitude'].values, s=10,\n           marker='o', color='black', transform=ccrs.PlateCarree())\n\n# Plot H/L symbols with metpy.plots.scattertext\n# and their corresponding height values 20 pts below the symbol\nscattertext(ax, hght.metpy.x[H_x], hght.metpy.y[H_y], 'H',\n            size=36, color='black', transform=ccrs.PlateCarree())\nscattertext(ax, hght.metpy.x[H_x], hght.metpy.y[H_y], hght.values[H_y, H_x],\n            size=12, color='black', formatter='.0f', loc=(0, -20), transform=ccrs.PlateCarree())\n\nscattertext(ax, hght.metpy.x[L_x], hght.metpy.y[L_y], 'L',\n            size=36, color='black', transform=ccrs.PlateCarree())\nscattertext(ax, hght.metpy.x[L_x], hght.metpy.y[L_y], hght.values[L_y, L_x],\n            size=12, color='black', formatter='.0f', loc=(0, -20), transform=ccrs.PlateCarree())\n\n# Add titles\nplt.title(f'Upper-air Observations at {level}-hPa Analysis Heights/Temperature',\n          loc='left')\nplt.title(f'Valid: {date}', loc='right');","type":"content","url":"/notebooks/synoptic/upperair-obs#create-difax-replication","position":9},{"hierarchy":{"lvl1":"Calculating Wind Shear"},"type":"lvl1","url":"/notebooks/synoptic/wind-shear-vectors-example","position":0},{"hierarchy":{"lvl1":"Calculating Wind Shear"},"content":"This example plots calculates the 850-500 hPa Bulk Wind Shear\n\nPlotting over a regional domain, accessing the Best Collection of GFS from the\nUnidata Thredds server, plots MSLP (hPa), 850-hPa Wind Vector (m/s), 500-hPa\nWind Vector (m/s), and the Wind Shear between the two layers (m/s)\n\n","type":"content","url":"/notebooks/synoptic/wind-shear-vectors-example","position":1},{"hierarchy":{"lvl1":"Calculating Wind Shear","lvl2":"Import necessary packages"},"type":"lvl2","url":"/notebooks/synoptic/wind-shear-vectors-example#import-necessary-packages","position":2},{"hierarchy":{"lvl1":"Calculating Wind Shear","lvl2":"Import necessary packages"},"content":"\n\nfrom datetime import datetime, UTC\n\nimport cartopy.crs as ccrs\nimport cartopy.feature as cfeature\nimport matplotlib.pyplot as plt\nfrom metpy.units import units\nimport numpy as np\nimport scipy.ndimage as ndimage\nfrom siphon.catalog import TDSCatalog\nfrom xarray.backends import NetCDF4DataStore\nimport xarray as xr\n\n","type":"content","url":"/notebooks/synoptic/wind-shear-vectors-example#import-necessary-packages","position":3},{"hierarchy":{"lvl1":"Calculating Wind Shear","lvl2":"Obtain data"},"type":"lvl2","url":"/notebooks/synoptic/wind-shear-vectors-example#obtain-data","position":4},{"hierarchy":{"lvl1":"Calculating Wind Shear","lvl2":"Obtain data"},"content":"\n\n# Construct a TDSCatalog instance pointing to the gfs dataset\nbest_gfs = TDSCatalog('http://thredds.ucar.edu/thredds/catalog/grib/'\n                      'NCEP/GFS/Global_0p5deg/catalog.xml')\n\n# Interface with the Best GFS Half Degree Forecast Time Series dataset\n# via NCSS directly\nncss = best_gfs.datasets['Best GFS Half Degree Forecast Time Series'].subset()\n\n","type":"content","url":"/notebooks/synoptic/wind-shear-vectors-example#obtain-data","position":5},{"hierarchy":{"lvl1":"Calculating Wind Shear","lvl2":"First Query for MSLP"},"type":"lvl2","url":"/notebooks/synoptic/wind-shear-vectors-example#first-query-for-mslp","position":6},{"hierarchy":{"lvl1":"Calculating Wind Shear","lvl2":"First Query for MSLP"},"content":"\n\n# Create our NCSS query with desired specifications\nquery = ncss.query()\nquery.lonlat_box(north=50, south=30, east=-80, west=-115)\nquery.time(datetime.now(UTC))\nquery.accept('netcdf4')\nquery.variables('MSLP_Eta_model_reduction_msl')\n\n# Obtain the data we've queried for as a netcdf4-python dataset\ndata = ncss.get_data(query)\n\n# Make into an xarray Dataset object\nds = xr.open_dataset(NetCDF4DataStore(data)).metpy.parse_cf()\n\n# Pull out the variables you want to use\nmslp_var = ds.MSLP_Eta_model_reduction_msl\ntime_var = ds.MSLP_Eta_model_reduction_msl.metpy.time\nlat_var = ds.latitude\nlon_var = ds.longitude\n\n","type":"content","url":"/notebooks/synoptic/wind-shear-vectors-example#first-query-for-mslp","position":7},{"hierarchy":{"lvl1":"Calculating Wind Shear","lvl2":"Second Query for 850-hPa data"},"type":"lvl2","url":"/notebooks/synoptic/wind-shear-vectors-example#second-query-for-850-hpa-data","position":8},{"hierarchy":{"lvl1":"Calculating Wind Shear","lvl2":"Second Query for 850-hPa data"},"content":"\n\n# Request data for 850-hPa winds\n# First clear the query's variables from previous query for MSLP\nquery.var = set()\nquery.vertical_level(85000)\nquery.variables('u-component_of_wind_isobaric',\n                'v-component_of_wind_isobaric')\n\ndata = ncss.get_data(query)\n\n# Make into an xarray Dataset object\nds_wind = xr.open_dataset(NetCDF4DataStore(data)).metpy.parse_cf()\n\nu_wind_var850 = ds_wind['u-component_of_wind_isobaric']\nv_wind_var850 = ds_wind['v-component_of_wind_isobaric']\n\nThird Query for 500-hPa data\n\n# Request data for 500-hPa winds\n# First clear the query's variables from previous query for 850-hPa data\nquery.var = set()\nquery.vertical_level(50000)\nquery.variables('u-component_of_wind_isobaric',\n                'v-component_of_wind_isobaric')\n\ndata = ncss.get_data(query)\n\n# Make into an xarray Dataset object\nds_wind = xr.open_dataset(NetCDF4DataStore(data)).metpy.parse_cf()\n\nu_wind_var500 = ds_wind['u-component_of_wind_isobaric']\nv_wind_var500 = ds_wind['v-component_of_wind_isobaric']\n\n","type":"content","url":"/notebooks/synoptic/wind-shear-vectors-example#second-query-for-850-hpa-data","position":9},{"hierarchy":{"lvl1":"Calculating Wind Shear","lvl2":"Data Manipulation"},"type":"lvl2","url":"/notebooks/synoptic/wind-shear-vectors-example#data-manipulation","position":10},{"hierarchy":{"lvl1":"Calculating Wind Shear","lvl2":"Data Manipulation"},"content":"\n\n# Get actual data values and remove any size 1 dimensions\nlat = lat_var.values.squeeze()\nlon = lon_var.values.squeeze()\nmslp = mslp_var.metpy.convert_units('hPa').squeeze()\nu_wind850 = u_wind_var850.squeeze()\nv_wind850 = v_wind_var850.squeeze()\nu_wind500 = u_wind_var500.squeeze()\nv_wind500 = v_wind_var500.squeeze()\n\n# Convert number of hours since the reference time into an actual date\ntime = time_var.values.astype('datetime64[ms]').astype('O').squeeze()\n\n# Combine 1D latitude and longitudes into a 2D grid of locations\nlon_2d, lat_2d = np.meshgrid(lon, lat)\n\n# Smooth mslp data\nmslp = ndimage.gaussian_filter(mslp, sigma=3, order=0)\n\nBegin making figure\n\n# Create new figure\nfig = plt.figure(figsize=(15, 12), facecolor='black')\n\n# Add the map and set the extent\nax = plt.axes(projection=ccrs.PlateCarree())\nax.set_extent([-108., -91., 33., 45.])\nax.patch.set_fill(False)\n\n# Add state boundaries to plot\nax.add_feature(cfeature.STATES, edgecolor='white', linewidth=2)\n\n# Contour the MSLP\nc = ax.contour(lon_2d, lat_2d, mslp, colors='lime', linewidths=6)\nax.clabel(c, fontsize=12, inline=1, inline_spacing=4, fmt='%i')\n\nwslice = slice(1, None, 4)\n# Plot 850-hPa wind vectors\nvectors850 = ax.quiver(lon_2d[wslice, wslice], lat_2d[wslice, wslice],\n                       u_wind850[wslice, wslice], v_wind850[wslice, wslice],\n                       headlength=4, headwidth=3, angles='xy',\n                       scale_units='xy', scale=12, color='gold',\n                       label='850mb wind')\n\n# Plot 500-hPa wind vectors\nvectors500 = ax.quiver(lon_2d[wslice, wslice], lat_2d[wslice, wslice],\n                       u_wind500[wslice, wslice], v_wind500[wslice, wslice],\n                       headlength=4, headwidth=3, angles='xy',\n                       scale_units='xy', scale=12, color='cornflowerblue',\n                       label='500mb wind')\n\n# Plot 500-850 shear\nshear = ax.quiver(lon_2d[wslice, wslice], lat_2d[wslice, wslice],\n                  u_wind500[wslice, wslice] - u_wind850[wslice, wslice],\n                  v_wind500[wslice, wslice] - v_wind850[wslice, wslice],\n                  headlength=4, headwidth=3, angles='xy', scale_units='xy',\n                  scale=12, color='deeppink', label='500-850mb shear')\n\n# Add a legend\nax.legend(('850mb wind', '500mb wind', '500-850mb shear'), loc=4)\n\n# Add a title to the plot\nplt.title('MSLP, 850mb Wind, 500mb Wind, and 500-850mb Vertical Wind Shear \\n'\n          f' for {time:%d %B %Y %H:%MZ}', color='white', size=14);","type":"content","url":"/notebooks/synoptic/wind-shear-vectors-example#data-manipulation","position":11},{"hierarchy":{"lvl1":"Synoptic Analysis"},"type":"lvl1","url":"/notebooks/synoptic","position":0},{"hierarchy":{"lvl1":"Synoptic Analysis"},"content":"This section covers how to perform a variety of analyses traditionally used in synoptic meteorolgy, ranging from basic plots on isobaric surfaces to Q-vectors and frontogenesis.","type":"content","url":"/notebooks/synoptic","position":1},{"hierarchy":{"lvl1":"Using Xarray for Data read and selection"},"type":"lvl1","url":"/notebooks/synoptic/xarray-500hpa-map","position":0},{"hierarchy":{"lvl1":"Using Xarray for Data read and selection"},"content":"Use Xarray module to read in model data from nomads server.\n\nThis example uses the xarray module to access data from the nomads server for\narchive NAM analysis data via OPeNDAP. Xarray makes it easier to select times\nand levels, although you still have to know the coordinate variable name. A\nsimple 500 hPa plot is created after selecting with xarray.\n\nImport all of our needed modules\n\nfrom datetime import datetime\n\nimport cartopy.crs as ccrs\nimport cartopy.feature as cfeature\nimport matplotlib.pyplot as plt\nimport metpy.calc as mpcalc\nfrom metpy.units import units\nimport numpy as np\nimport xarray as xr\n\n","type":"content","url":"/notebooks/synoptic/xarray-500hpa-map","position":1},{"hierarchy":{"lvl1":"Using Xarray for Data read and selection","lvl2":"Accessing data using Xarray"},"type":"lvl2","url":"/notebooks/synoptic/xarray-500hpa-map#accessing-data-using-xarray","position":2},{"hierarchy":{"lvl1":"Using Xarray for Data read and selection","lvl2":"Accessing data using Xarray"},"content":"\n\n# Specify our date/time of product desired\ndt = datetime(2016, 4, 16, 18)\n\n# Construct our OPeNDAP access URL\nbase_url = 'https://www.ncei.noaa.gov/thredds/dodsC/model-namanl-old/'\ndata = xr.open_dataset(f'{base_url}{dt:%Y%m}/{dt:%Y%m%d}/'\n                       f'namanl_218_{dt:%Y%m%d}_{dt:%H}00_000.grb').metpy.parse_cf()\n\nNAM data is in a projected coordinate and you get back the projection\nX and Y values in km\n\n# Create a 2-d meshgrid of our x, y coordinates\n# manually converted to meters (km * 1000)\n#x, y = np.meshgrid(data['x'].values * 1000, data['y'].values * 1000)\nx = data.Geopotential_height_isobaric.metpy.x.metpy.convert_units('meter').values\ny = data.Geopotential_height_isobaric.metpy.y.metpy.convert_units('meter').values\n\nGetting the valid times in a more useable format\n\n# Get the valid times from the file\nvtimes = data.Geopotential_height_isobaric.metpy.time.data.astype('datetime64[ms]').astype('O')\nprint(vtimes)\n\nXarray has some nice functionality to choose the time and level that\nyou specifically want to use. In this example the time variable is ‘time’ and\nthe level variable is ‘isobaric1’. Unfortunately, these can be different with\neach file you use, so you’ll always need to check what they are by listing\nthe coordinate variable names\n\n# print(data.Geopotential_height.coords)\nhght_500 = data.Geopotential_height_isobaric.metpy.sel(time1=vtimes[0], vertical=500*units.hPa)\nuwnd_500 = data['u-component_of_wind_isobaric'].metpy.sel(time1=vtimes[0], vertical=500*units.hPa)\nvwnd_500 = data['v-component_of_wind_isobaric'].metpy.sel(time1=vtimes[0], vertical=500*units.hPa)\n\n","type":"content","url":"/notebooks/synoptic/xarray-500hpa-map#accessing-data-using-xarray","position":3},{"hierarchy":{"lvl1":"Using Xarray for Data read and selection","lvl2":"Now make the 500-hPa map"},"type":"lvl2","url":"/notebooks/synoptic/xarray-500hpa-map#now-make-the-500-hpa-map","position":4},{"hierarchy":{"lvl1":"Using Xarray for Data read and selection","lvl2":"Now make the 500-hPa map"},"content":"\n\n# Must set data projection, NAM is LCC projection\ndatacrs = data.Geopotential_height_isobaric.metpy.cartopy_crs\n\n# A different LCC projection for the plot.\nplotcrs = ccrs.LambertConformal(central_latitude=45., central_longitude=-100.,\n                                standard_parallels=[30, 60])\n\nfig = plt.figure(figsize=(17., 11.))\nax = plt.axes(projection=plotcrs)\nax.coastlines('50m', edgecolor='black')\nax.add_feature(cfeature.STATES, linewidth=0.5)\nax.set_extent([-130, -67, 20, 50], ccrs.PlateCarree())\n\nclev500 = np.arange(5100, 6000, 60)\ncs = ax.contour(x, y, mpcalc.smooth_n_point(hght_500, 9, 5), clev500,\n                colors='k', linewidths=2.5, linestyles='solid', transform=datacrs)\nax.clabel(cs, fontsize=12, colors='k', inline=1, inline_spacing=8,\n          fmt='%i', rightside_up=True, use_clabeltext=True)\n\n# Here we put boxes around the clabels with a black boarder white facecolor\n# `labelTexts` necessary as ~cartopy.mpl.contour.GeoContourSet.clabel\n# does not return list of texts as of 0.18\nfor t in cs.labelTexts:\n    t.set_bbox({'fc': 'w'})\n\n# Transform Vectors before plotting, then plot wind barbs.\nwind_slice = slice(None, None, 16)\nax.barbs(x[wind_slice], y[wind_slice],\n         uwnd_500.data[wind_slice, wind_slice], vwnd_500.data[wind_slice, wind_slice],\n         length=7, transform=datacrs)\n\n# Add some titles to make the plot readable by someone else\nplt.title('500-hPa Geopotential Heights (m)', loc='left')\nplt.title(f'VALID: {vtimes[0]}', loc='right');","type":"content","url":"/notebooks/synoptic/xarray-500hpa-map#now-make-the-500-hpa-map","position":5}]}